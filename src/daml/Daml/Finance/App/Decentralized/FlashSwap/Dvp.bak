module DeFi.FlashSwap.Dvp where

import DA.Finance.Asset (AssetDeposit(..), Transfer(..), SetObservers(..))
import DA.Finance.Types (Asset)
import DA.Optional
import DA.Set (Set)
import DA.Set qualified as S
import DeFi.Interface.FlashSwapAction

data Allocation = Allocation with
    asset: Asset
    providers: Set Party
    owners: Set Party
    allocationCid: Optional (ContractId AssetDeposit)
  deriving (Eq, Show)

template Dvp with
    delivery: Allocation
    payment: Allocation
  where
    signatory delivery.owners, payment.owners

    let
      allocate (allocation : Allocation) (tokenCid : ContractId AssetDeposit) = do
        let
          otherAllocation = if (allocation == delivery)
            then payment else delivery
        cid <- exercise tokenCid SetObservers with newObservers = otherAllocation.owners
        let
          newAllocation = allocation with allocationCid = Some(cid)
        token <- fetch cid
        assertMsg "asset matches" (allocation.asset == token.asset)
        assertMsg "providers matches" (allocation.providers == token.providers)
        assertMsg "owners matches" (allocation.owners == token.owners)
        if (allocation == delivery) then
          create this with delivery = newAllocation
        else
          create this with payment = newAllocation

      flashSwap (xAllocation: Allocation)
                (yAllocation: Allocation)
                (actionCid: ContractId FlashSwapAction) =
        do
          -- get Y from counterparty
          let yTokenCid = fromSome yAllocation.allocationCid
          yTokenCid <- exercise yTokenCid SetObservers with newObservers = S.empty
          yTokenCid <- exercise yTokenCid Transfer with receivers = xAllocation.owners
          yToken <- fetch yTokenCid

          -- use Y in FlasSwapAction returning X
          (xTokenCid, sideEffectCids) <- exercise actionCid ExecuteAction with
            choiceControllers = xAllocation.owners
            tokenIn = yToken
            tokenInCid = yTokenCid
            tokenOut = AssetDeposit with
              providers = xAllocation.providers
              owners = xAllocation.owners
              asset = xAllocation.asset
              lockers = S.empty
              observers = S.empty

          -- transfer X to counterparty
          xTokenCid <- exercise xTokenCid Transfer with receivers = yAllocation.owners

          return (xTokenCid, sideEffectCids)

    choice Dvp_Deliver: ContractId Dvp
      with cid: ContractId AssetDeposit
      controller delivery.owners
      do
        allocate delivery cid

    choice Dvp_Pay: ContractId Dvp
      with cid: ContractId AssetDeposit
      controller payment.owners
      do
        allocate payment cid

    postconsuming choice Dvp_FlashPayAndSettle: (ContractId AssetDeposit, [ContractId AssetDeposit])
      with
        actionCid: ContractId FlashSwapAction
      controller payment.owners
      do
        flashSwap payment delivery actionCid

    postconsuming choice Dvp_FlashDeliverAndSettle: (ContractId AssetDeposit, [ContractId AssetDeposit])
      with
        actionCid: ContractId FlashSwapAction
      controller delivery.owners
      do
        flashSwap delivery payment actionCid

    choice Dvp_Settle: (ContractId AssetDeposit, ContractId AssetDeposit) with
        actors: Set Party
      controller actors
      do
        let deliveryCid = fromSome delivery.allocationCid
            paymentCid = fromSome payment.allocationCid
        cid1T <- exercise deliveryCid Transfer with receivers = payment.owners
        cid2T <- exercise paymentCid Transfer with receivers = delivery.owners
        cid1T <- exercise cid1T SetObservers with newObservers = S.empty
        cid2T <- exercise cid2T SetObservers with newObservers = S.empty
        return (cid2T, cid1T)


-- Example of Templates implementing the FlasSwapAction interface

-- settle trade once counterparties have committed
-- alice *<-> ccp <->* bob
template SettleTrade with
    ccp: Set Party
    dvp1LeftAllocatedCid: ContractId Dvp
    dvp2RightAllocatedCid: ContractId Dvp
  where
    signatory ccp

    interface instance FlashSwapAction for SettleTrade where
      view = View {}
      choiceBody = \tokenInCid -> do
          dvp1Cid <- exercise dvp1LeftAllocatedCid Dvp_Pay
            with cid = tokenInCid
          (cid1, cid2) <- exercise dvp1Cid Dvp_Settle
            with actors = ccp
          dvp2Cid <- exercise dvp2RightAllocatedCid Dvp_Deliver
            with cid = cid2
          (cid3, cid4) <- exercise dvp2Cid Dvp_Settle
            with actors = ccp
          return (cid3, [cid1, cid4])

-- settle Dvp where counterparty has committed delivery
-- alice *<-> owners
template PayAndSettleDvp with
    owners: Set Party
    dvpAllocatedCid: ContractId Dvp
  where
    signatory owners

    interface instance FlashSwapAction for PayAndSettleDvp where
      view = View {}
      choiceBody = \paymentCid -> do
          dvpCid <- exercise dvpAllocatedCid Dvp_Pay
            with cid = paymentCid
          (cid1, cid2) <- exercise dvpCid Dvp_Settle
            with actors = owners
          return (cid2, [cid1])

-- settle trade where counterparty has committed payment
-- ccp <->* bob
template DeliverAndSettleDvp with
    ccp: Set Party
    dvp2RightAllocatedCid: ContractId Dvp
  where
    signatory ccp

    interface instance FlashSwapAction for DeliverAndSettleDvp where
      view = View {}
      choiceBody = \deliveryTokenCid -> do
          dvpCid <- exercise dvp2RightAllocatedCid Dvp_Deliver
            with cid = deliveryTokenCid
          (cid1, cid2) <- exercise dvpCid Dvp_Settle
            with actors = ccp
          return (cid1, [cid2])