-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Setup.Scenario.SecuritiesLending where

import DA.Date (addDays, toDateUTC, toGregorian)
import DA.Map (empty, fromList)
import DA.Set (singleton)
import DA.Time (time)
import Daml.Finance.App.Interface.Lending.BorrowAgreement qualified as BorrowAgreement (Repay(..))
import Daml.Finance.App.Interface.Lending.Service qualified as Lending (AcceptBorrowOffer(..), CreateBorrowOffer(..), I, RequestBorrowOffer(..))
import Daml.Finance.App.Lending.Service qualified as Lending (T)
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Settlement.Hierarchy qualified as Settlement (Hierarchy(..))
import Daml.Finance.App.Setup.Payoff
import Daml.Finance.App.Setup.Util.Script.Common
import Daml.Finance.App.Setup.Util.Script.Role
import Daml.Finance.App.Setup.Util.Script.Service
import Daml.Finance.App.Setup.Util.Script.Workflow
import Daml.Script

run : Script [PartyInfo]
run  = do
  let scenario = "Securities Lending"
  parties <- allocateParties scenario ["Operator", "Public", "CentralBank", "Registry", "Borrower", "Lender"]
  let
    all@[operator, public, centralBank, registry, borrower, lender] = map (.id) parties
    pub = fromList [("Public", singleton public)]

  -- Factories
  let
    assets = ["TSLA", "DEAL1"]
    settlementPaths = [[borrower], [lender]]
    cashRoute = Settlement.Hierarchy with rootCustodian = centralBank; pathsToRootCustodian = settlementPaths
    secRoute = Settlement.Hierarchy with rootCustodian = registry; pathsToRootCustodian = settlementPaths
    paths = fromList $ ("USD", cashRoute) :: map (\a -> (a, secRoute)) assets

  -- Roles
  createOperatorRole  operator
  createCustodianRole operator centralBank
  createCustodianRole operator registry
  createCustodianRole operator lender

  -- Create custody services
  createCustodyService      operator centralBank  borrower  public paths
  createCustodyService      operator centralBank  lender    public paths
  createCustodyService      operator registry     borrower  public paths
  createCustodyService      operator registry     lender    public paths
  createCustodyService      operator lender       borrower  public paths
  createLendingService      operator lender       borrower
  createStructuringService  operator registry     lender
  createLifecycleService    operator registry     lender

  -- Accounts
  borrowerLenderAccount <- createAccount operator lender      borrower  public "Borrower@Lender"       empty
  borrowerCashAccount   <- createAccount operator centralBank borrower  public "Borrower@CentralBank"  empty
  lenderCashAccount     <- createAccount operator centralBank lender    public "Lender@CentralBank"    empty
  lenderSecAccount      <- createAccount operator registry    lender    public "Lender@Registry"       empty
  borrowerSecAccount    <- createAccount operator registry    borrower  public "Borrower@Registry"     empty

  -- Time
  t <- getTime
  let
    today = toDateUTC t
    todayTime = time today 0 0 0
    (todayYear, todayMonth, todayDay) = toGregorian today
  createClockAndEvent all today (singleton public)

  -- Instruments
  usd   <- originateToken   centralBank centralBank pub todayTime "USD" "United States Dollar"
  tsla  <- originateEquity  registry    registry    pub todayTime "TSLA" "Tesla, Inc. Common Stock"
  deal1 <- originateGeneric registry    lender      pub todayTime "DEAL1" "Loan of TSLA @ 0.2%" $ loan today (addDays today 28) tsla 0.002 usd [addDays today 7, addDays today 14, addDays today 21, addDays today 28]

  -- Data
  createAccountDirectory lender   [(usd, lenderCashAccount), (tsla, lenderSecAccount)] $ singleton public
  createAccountDirectory borrower [(usd, borrowerCashAccount), (tsla, borrowerSecAccount), (deal1, borrowerLenderAccount)] $ singleton public

  -- Distribution
  deposit operator lender borrower public (qty    10_000.0 deal1) borrowerLenderAccount
  borrowedCid   <- coerceContractId <$> deposit operator registry    lender   public (qty     1_000.0 tsla) lenderSecAccount
  collateralCid <- coerceContractId <$> deposit operator centralBank borrower public (qty 1_000_000.0 usd) borrowerCashAccount
  interestCid   <- coerceContractId <$> deposit operator centralBank borrower public (qty     1_000.0 usd) borrowerCashAccount

  -- Workflows
  let
    doLoan = do
      let
        borrowed   = qty     1_000.0 tsla
        interest   = qty     1_000.0 usd
        collateral = qty 1_000_000.0 usd

      Some (serviceCid, _) <- queryContractKey @Lending.T borrower (operator, lender, borrower)
      borrowOfferRequestCid <- submit borrower do exerciseCmd (toInterfaceContractId @Lending.I serviceCid) Lending.RequestBorrowOffer with dealId = Id "BORROW1"; description = "Loan of 1000 TSLA until " <> show today; borrowed; maturity = today
      borrowOfferCid <- submit lender do exerciseCmd (toInterfaceContractId @Lending.I serviceCid) Lending.CreateBorrowOffer with borrowOfferRequestCid; interest; collateral; borrowedCid; lenderBorrowedAccount = lenderSecAccount; lenderInterestAccount = lenderCashAccount
      (borrowedCid, borrowAgreementCid) <- submitMulti [borrower] [public] do exerciseCmd (toInterfaceContractId @Lending.I serviceCid) Lending.AcceptBorrowOffer with borrowOfferCid; collateralCid; account = borrowerSecAccount
      submitMulti [borrower] [public] do exerciseCmd borrowAgreementCid BorrowAgreement.Repay with borrowedCid; interestCid

  --doLoan

  pure parties
