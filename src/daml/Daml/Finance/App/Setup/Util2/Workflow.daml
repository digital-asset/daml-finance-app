-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Setup.Util2.Workflow where

import DA.Date (DayOfWeek, toGregorian)
import DA.List (head)
import DA.Map qualified as M (Map, fromList)
import DA.Set (fromList, singleton)
import DA.Text (parseInt)
import DA.Time (time)
import Daml.Finance.App.Custody.Service qualified as CustodyService (T)
import Daml.Finance.App.Data.AccountDirectory (AccountDirectory(..))
import Daml.Finance.App.Distribution.Auction.Service qualified as AuctionService (T)
import Daml.Finance.App.Distribution.Bidding.Service qualified as BiddingService (T)
import Daml.Finance.App.Distribution.Fund.Service qualified as FundService (T)
import Daml.Finance.App.Distribution.Investment.Service qualified as InvestmentService (T)
import Daml.Finance.App.Interface.Custody.Service qualified as CustodyService (Deposit(..), I, OpenAccount(..), RequestDeposit(..), RequestOpenAccount(..))
import Daml.Finance.App.Interface.Distribution.Auction.Auction qualified as Auction (I)
import Daml.Finance.App.Interface.Distribution.Auction.Service qualified as AuctionService (CreateAuction(..), I, ProcessAuction(..), RequestCreateAuction(..))
import Daml.Finance.App.Interface.Distribution.Bidding.Bid qualified as Bid (I)
import Daml.Finance.App.Interface.Distribution.Bidding.Service qualified as BiddingService (CreateBid(..), I, RequestCreateBid(..))
import Daml.Finance.App.Interface.Distribution.Fund.Fund qualified as Fund (I)
import Daml.Finance.App.Interface.Distribution.Fund.PooledInvestmentRequest qualified as PooledInvestmentRequest (I)
import Daml.Finance.App.Interface.Distribution.Fund.Service qualified as FundService (FulfillPooledInvestmentRequest(..), I, PoolInvestmentRequests(..))
import Daml.Finance.App.Interface.Distribution.Investment.InvestmentRequest qualified as InvestmentRequest (I)
import Daml.Finance.App.Interface.Distribution.Investment.Service qualified as InvestmentService (I, RequestInvestment(..),)
import Daml.Finance.App.Interface.Issuance.Issuance qualified as Issuance (I)
import Daml.Finance.App.Interface.Issuance.Service qualified as IssuanceService (I, Issue(..), RequestIssue(..))
import Daml.Finance.App.Interface.Lifecycle.Service qualified as LifecycleService (I, DeclareDividend(..), DeclareStockSplit(..), DeclareReplacement(..))
import Daml.Finance.App.Interface.Listing.Listing qualified as Listing (I)
import Daml.Finance.App.Interface.Listing.Service qualified as ListingService (I, List(..), RequestListing(..))
import Daml.Finance.App.Interface.Trading.Order qualified as Order (I, Side(..), View)
import Daml.Finance.App.Interface.Trading.Service qualified as TradingService (CreateOrder(..), I, RequestCreateOrder(..))
import Daml.Finance.App.Issuance.Service qualified as IssuanceService (T)
import Daml.Finance.App.Lifecycle.Service qualified as LifecycleService (T)
import Daml.Finance.App.Listing.Service qualified as ListingService (T)
import Daml.Finance.App.Trading.Service qualified as TradingService (T)
import Daml.Finance.Data.Numeric.Observation qualified as Data (Observation(..))
import Daml.Finance.Data.Reference.HolidayCalendar qualified as Data (HolidayCalendar(..))
import Daml.Finance.Data.Time.DateClock qualified as Data (DateClock(..))
import Daml.Finance.Data.Time.DateClockUpdate qualified as Data (DateClockUpdateEvent(..))
import Daml.Finance.Data.Time.DateClock.Types (Unit(..))
import Daml.Finance.Instrument.Bond.FixedRate.Instrument qualified as FixedRate (Instrument(..))
import Daml.Finance.Instrument.Bond.FloatingRate.Instrument qualified as FloatingRate (Instrument(..))
import Daml.Finance.Instrument.Bond.InflationLinked.Instrument qualified as InflationLinked (Instrument(..))
import Daml.Finance.Instrument.Bond.ZeroCoupon.Instrument qualified as ZeroCoupon (Instrument(..))
import Daml.Finance.Instrument.Equity.Instrument qualified as Equity (Instrument(..))
import Daml.Finance.Instrument.Generic.Instrument qualified as Generic (Instrument(..))
import Daml.Finance.Instrument.Swap.CreditDefault.Instrument qualified as CreditDefaultSwap (Instrument(..))
import Daml.Finance.Instrument.Token.Instrument qualified as Token (Instrument(..))
import Daml.Finance.Interface.Account.Account qualified as Account (Controllers(..))
import Daml.Finance.Interface.Claims.Types (C)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (GetView(..), I, Reference(..))
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (I)
import Daml.Finance.Interface.Lifecycle.Observable.TimeObservable qualified as TimeObservable (I)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), ClaimResult(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (I)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (I, Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types qualified as Settlement (Allocation, Approval)
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentKey, InstrumentQuantity, Parties, PartiesMap)
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayAdjustment(..), BusinessDayConventionEnum, HolidayCalendarData(..))
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum, RollConventionEnum(..))
import Daml.Finance.Interface.Types.Date.Schedule (Frequency(..), PeriodicSchedule(..))

-- getService : forall t k . (Template t, TemplateKey t k) => Party -> k -> Update (ContractId t)
-- getService actor k = do
--   opt <- queryContractKey @t actor k
--   case opt of
--     Some (serviceCid, service) -> pure serviceCid
--     None -> fail $ "Service not found"

-- getServiceInterface : forall t k i . (Template t, TemplateKey t k, HasInterfaceTypeRep i) => Party -> (Party, Party, Party) -> Update (ContractId i)
-- getServiceInterface actor k = do
--   svc <- getService @t actor k
--   pure $ toInterfaceContractId @i svc

createAccount : Party -> Party -> Party -> Party -> Text -> PartiesMap -> Update AccountKey
createAccount operator provider customer public id observers = do
  let controllers = Account.Controllers with outgoing = singleton customer; incoming = singleton customer
  serviceCid <- toInterfaceContractId @CustodyService.I . fst <$> fetchByKey @CustodyService.T (operator, provider, customer)
  openAccountRequestCid <- exercise serviceCid CustodyService.RequestOpenAccount with id = Id id; description = id; controllers; observers
  snd <$> exercise serviceCid CustodyService.OpenAccount with openAccountRequestCid

createAccountDirectory : Party -> [(InstrumentKey, AccountKey)] -> Parties -> Update (ContractId AccountDirectory)
createAccountDirectory provider mapping observers = do
  create AccountDirectory with provider; accounts = M.fromList (map (\(i, a) -> (i.id, a)) mapping); observers

-- | Create a `Reference` for an instrument.
-- Note: This should only be called together with an instrument creation
createReference : ContractId Instrument.I -> Party -> Party -> PartiesMap -> Update InstrumentKey
createReference cid depository issuer observers = do
  instrumentView <- exercise cid Instrument.GetView with viewer = issuer
  let ref = Instrument.Reference with instrumentView; cid; observers
  create ref
  pure $ key ref

-- | Create a schedule for periodic payments.
createPaymentPeriodicSchedule : Date -> [Text] -> BusinessDayConventionEnum -> PeriodEnum -> Int -> Date -> Date -> PeriodicSchedule
createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate = do
  let
    (y, m, d) = toGregorian firstCouponDate
    periodicSchedule = PeriodicSchedule with
      businessDayAdjustment =
        BusinessDayAdjustment with
          calendarIds = holidayCalendarIds
          convention = businessDayConvention
      effectiveDateBusinessDayAdjustment = None
      terminationDateBusinessDayAdjustment = None
      frequency =
        Frequency with
          rollConvention = DOM d
          period = couponPeriod
          periodMultiplier = couponPeriodMultiplier
      effectiveDate = issueDate
      firstRegularPeriodStartDate = Some firstCouponDate
      lastRegularPeriodEndDate = Some maturityDate
      stubPeriodType = None
      terminationDate = maturityDate
  periodicSchedule

createClockAndEvent : [Party] -> Date -> Parties -> Update (ContractId TimeObservable.I, ContractId Event.I)
createClockAndEvent providers today observers = do
  let
    description = show today
    id = Id description
    date = Unit today
    clock = Data.DateClock with providers = fromList providers; date; id; description; observers
  clockCid <- toInterfaceContractId <$> create clock
  eventCid <- toInterfaceContractId <$> create Data.DateClockUpdateEvent with providers = fromList providers; id; description; eventTime = time today 0 0 0; date = today; observers
  pure (clockCid, eventCid)

createObservation : Party -> Text -> [(Time, Decimal)] -> M.Map Text Parties -> Update (ContractId NumericObservable.I)
createObservation provider id observations observers = do
  toInterfaceContractId <$> create Data.Observation with provider; id = Id id; observations = M.fromList observations; observers

createCalendar : Party -> Text -> [DayOfWeek] -> [Date] -> M.Map Text Parties -> Update (ContractId Data.HolidayCalendar)
createCalendar provider id weekend holidays observers = do
  let calendar = HolidayCalendarData with id; weekend; holidays
  create Data.HolidayCalendar with provider; calendar; observers

originateToken : Party -> Party -> PartiesMap -> Time -> Text -> Text -> Update InstrumentKey
originateToken depository issuer observers validAsOf id description = do
  cid <- coerceContractId <$> create Token.Instrument with depository; issuer; id = Id id; version = "0"; observers; validAsOf; description
  createReference cid depository issuer observers

originateEquity : Party -> Party -> PartiesMap -> Time -> Text -> Text -> Update InstrumentKey
originateEquity depository issuer observers validAsOf id description = do
  cid <- coerceContractId <$> create Equity.Instrument with depository; issuer; id = Id id; version = "0"; observers; validAsOf; description
  createReference cid depository issuer observers

originateGeneric : Party -> Party -> PartiesMap -> Time -> Text -> Text -> C -> Update InstrumentKey
originateGeneric depository issuer observers acquisitionTime id description claims = do
  cid <- coerceContractId <$> create Generic.Instrument with depository; issuer; id = Id id; description; version = "0"; acquisitionTime; claims; observers; lastEventTimestamp = acquisitionTime
  createReference cid depository issuer observers

originateFixedRateBond : Party -> Party -> Text -> Text -> PartiesMap -> Time -> Date -> [Text] -> Party -> Date-> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Update InstrumentKey
originateFixedRateBond depository issuer id description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  cid <- toInterfaceContractId @Instrument.I <$> create FixedRate.Instrument with depository; issuer; id = Id id; version = "0"; description; observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; couponRate; currency
  createReference cid depository issuer observers

originateZeroCouponBond : Party -> Party -> Text -> Text -> PartiesMap -> Time -> Date -> Date -> InstrumentKey -> Update InstrumentKey
originateZeroCouponBond depository issuer id description observers lastEventTimestamp issueDate maturityDate currency = do
  cid <- toInterfaceContractId <$> create ZeroCoupon.Instrument with depository; issuer; id = Id id; version = "0"; description; observers; lastEventTimestamp; issueDate; maturityDate; currency
  createReference cid depository issuer observers

originateFloatingRateBond : Party -> Party -> Text -> Text -> PartiesMap -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Text -> Update InstrumentKey
originateFloatingRateBond depository issuer id description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency referenceRateId = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  cid <- toInterfaceContractId <$> create FloatingRate.Instrument with depository; issuer; id = Id id; version = "0"; description; observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; couponSpread=couponRate; referenceRateId; currency
  createReference cid depository issuer observers

originateInflationLinkedBond : Party -> Party -> Text -> Text -> PartiesMap -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Text -> Decimal -> Update InstrumentKey
originateInflationLinkedBond depository issuer id description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency inflationIndexId inflationIndexBaseValue = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  cid <- toInterfaceContractId <$> create InflationLinked.Instrument with depository; issuer; id = Id id; version = "0"; description; observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; couponRate; inflationIndexId; currency; inflationIndexBaseValue
  createReference cid depository issuer observers

originateCreditDefaultSwap : Party -> Party -> Text -> Text -> PartiesMap -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> InstrumentKey -> Text -> Text -> Bool -> Update InstrumentKey
originateCreditDefaultSwap depository issuer id description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention fixRate couponPeriod couponPeriodMultiplier currency defaultProbabilityReferenceId recoveryRateReferenceId ownerReceivesFix = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  cid <- toInterfaceContractId <$> create CreditDefaultSwap.Instrument with depository; issuer; id = Id id; version = "0"; description; observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; currency; fixRate; defaultProbabilityReferenceId; recoveryRateReferenceId; ownerReceivesFix
  createReference cid depository issuer observers

transfer : Party -> AccountKey -> Party -> ContractId Transferable.I -> Update (ContractId Transferable.I)
transfer from toAccount public depositCid = do
  exercise depositCid Transferable.Transfer with actors = fromList [from, toAccount.owner]; newOwnerAccount = toAccount

deposit : Party -> Party -> Party -> Party -> InstrumentQuantity -> AccountKey -> Update (ContractId Holding.I)
deposit operator provider customer public quantity account = do
  serviceCid <- toInterfaceContractId @CustodyService.I . fst <$> fetchByKey @CustodyService.T (operator, provider, customer)
  depositRequestCid <- exercise serviceCid CustodyService.RequestDeposit with quantity; account
  exercise serviceCid CustodyService.Deposit with depositRequestCid

issue : Party -> Party -> Party -> Party -> InstrumentQuantity -> AccountKey -> Update (ContractId Issuance.I, ContractId Holding.I)
issue operator provider customer public quantity account = do
  let
    issuanceId = Id $ "ISSUANCE-" <> show quantity.unit.id
    description = "Issuance of " <> show quantity.amount <> " " <> show quantity.unit.id
  serviceCid <- toInterfaceContractId @IssuanceService.I . fst <$> fetchByKey @IssuanceService.T (operator, provider, customer)
  issueRequestCid <- exercise serviceCid IssuanceService.RequestIssue with issuanceId; description; quantity; account
  exercise serviceCid IssuanceService.Issue with issueRequestCid

list : Party -> Party -> Party -> Id -> Text -> InstrumentKey -> InstrumentKey -> Parties -> Update (ContractId Listing.I)
list operator provider customer listingId description tradedInstrument quotedInstrument observers = do
  serviceCid <- toInterfaceContractId @ListingService.I . fst <$> fetchByKey @ListingService.T (operator, provider, customer)
  listingRequestCid <- exercise serviceCid ListingService.RequestListing with listingId; description; tradedInstrument; quotedInstrument; observers
  exercise serviceCid ListingService.List with listingRequestCid

createOrder : Party -> Party -> Party -> Party -> Id -> Order.Side -> InstrumentQuantity -> InstrumentQuantity -> Id -> AccountKey -> [ContractId Order.I] -> ContractId Fungible.I -> Parties -> Update (Optional (ContractId Order.I, Order.View))
createOrder operator provider customer public id side quantity price listingId account orderCids holdingCid observers = do
  let
    depository = if side == Order.Buy then quantity.unit.depository else price.unit.depository
    requiredQuantity = if side == Order.Buy then price with amount = price.amount * quantity.amount else quantity
  serviceCid <- toInterfaceContractId @TradingService.I . fst <$> fetchByKey @TradingService.T (operator, provider, customer)
  createOrderRequestCid <- exercise serviceCid TradingService.RequestCreateOrder with id; listingId; quantity; price; side; collateralCid = holdingCid; account; orderCids; observers
  exercise serviceCid TradingService.CreateOrder with createOrderRequestCid

createBidOrder : Party -> Party -> Party -> Party -> Id -> InstrumentQuantity -> InstrumentQuantity -> Id -> AccountKey -> [ContractId Order.I] -> ContractId Fungible.I -> Parties -> Update (Optional (ContractId Order.I, Order.View))
createBidOrder operator provider customer public id = createOrder operator provider customer public id Order.Buy

createAskOrder : Party -> Party -> Party -> Party -> Id -> InstrumentQuantity -> InstrumentQuantity -> Id -> AccountKey -> [ContractId Order.I] -> ContractId Fungible.I -> Parties -> Update (Optional (ContractId Order.I, Order.View))
createAskOrder operator provider customer public id = createOrder operator provider customer public id Order.Sell

createAuction : Party -> Party -> Party -> Party -> Id -> Text -> InstrumentQuantity -> InstrumentKey -> Decimal -> ContractId Fungible.I -> AccountKey -> Update (ContractId Auction.I)
createAuction operator provider customer public auctionId description quantity currency floor collateralCid receivableAccount = do
  serviceCid <- toInterfaceContractId @AuctionService.I . fst <$> fetchByKey @AuctionService.T (operator, provider, customer)
  createAuctionRequestCid <- exercise serviceCid AuctionService.RequestCreateAuction with auctionId; description; quantity; currency; floor; collateralCid; receivableAccount; observers = singleton public
  exercise serviceCid AuctionService.CreateAuction with createAuctionRequestCid

createAuctionBid : Party -> Party -> Party -> Party -> ContractId Auction.I -> Decimal -> Decimal -> ContractId Fungible.I -> AccountKey -> Update (ContractId Bid.I)
createAuctionBid operator provider customer public auctionCid amount price collateralCid receivableAccount = do
  serviceCid <- toInterfaceContractId @BiddingService.I . fst <$> fetchByKey @BiddingService.T (operator, provider, customer)
  createBidRequestCid <- exercise serviceCid BiddingService.RequestCreateBid with auctionCid; amount; price; collateralCid; receivableAccount
  exercise serviceCid BiddingService.CreateBid with createBidRequestCid

processAuction : Party -> Party -> Party -> Party -> ContractId Auction.I -> [ContractId Bid.I] -> Update (ContractId Auction.I)
processAuction operator provider customer public auctionCid bidCids = do
  serviceCid <- toInterfaceContractId @AuctionService.I . fst <$> fetchByKey @AuctionService.T (operator, provider, customer)
  exercise serviceCid AuctionService.ProcessAuction with auctionCid; bidCids

declareDividend : Party -> Party -> Party -> Party -> InstrumentKey -> Time -> [InstrumentQuantity] -> Update (ContractId Effect.I)
declareDividend operator provider issuer public equity effectiveTime perUnitDistribution = do
  let
    id = "Dividend-" <> show equity.id <> "-" <> equity.version
    Some version = parseInt equity.version
  serviceCid <- toInterfaceContractId @LifecycleService.I . fst <$> fetchByKey @LifecycleService.T (operator, provider, issuer)
  head <$> exercise serviceCid LifecycleService.DeclareDividend with
    equity
    newVersion = show (version + 1)
    eventId = Id id
    description = id
    effectiveTime
    perUnitDistribution

declareReplacement : Party -> Party -> Party -> Party -> InstrumentKey -> Time -> [InstrumentQuantity] -> Update (ContractId Effect.I)
declareReplacement operator provider issuer public equity effectiveTime perUnitReplacement = do
  let id = "Replacement-" <> show equity.id <> "-" <> equity.version
  serviceCid <- toInterfaceContractId @LifecycleService.I . fst <$> fetchByKey @LifecycleService.T (operator, provider, issuer)
  head <$> exercise serviceCid LifecycleService.DeclareReplacement with
    equity
    eventId = Id id
    description = id
    effectiveTime
    perUnitReplacement

declareStockSplit : Party -> Party -> Party -> Party -> InstrumentKey -> Time -> Decimal -> Update (ContractId Effect.I)
declareStockSplit operator provider issuer public equity effectiveTime adjustmentFactor = do
  let
    id = "StockSplit-" <> show equity.id <> "-" <> equity.version
    Some version = parseInt equity.version
  serviceCid <- toInterfaceContractId @LifecycleService.I . fst <$> fetchByKey @LifecycleService.T (operator, provider, issuer)
  head <$> exercise serviceCid LifecycleService.DeclareStockSplit with
    equity
    newVersion = show (version + 1)
    eventId = Id id
    description = id
    effectiveTime
    adjustmentFactor

claimEffect : Party -> Party -> Party -> Party -> ContractId Effect.I -> [ContractId Holding.I] -> Id -> Update (ContractId Batch.I, [ContractId Instruction.I])
claimEffect operator custodian owner public effectCid holdingCids batchId = do
  service <- snd <$> fetchByKey @CustodyService.T (operator, custodian, owner)
  Claim.ClaimResult{batchCid; instructionCids} <- exercise service.claimRuleCid Claim.ClaimEffect with claimer = owner; effectCid; holdingCids; batchId
  pure (batchCid, instructionCids)

allocateAndApprove : Party -> Party -> ContractId Instruction.I -> Settlement.Allocation -> Settlement.Approval -> Update (ContractId Instruction.I)
allocateAndApprove operator settler instructionCid allocation approval = do
  i <- view <$> fetch instructionCid
  instructionCid <- fst <$> exercise instructionCid Instruction.Allocate with actors = singleton settler; allocation
  exercise instructionCid Instruction.Approve with actors = singleton settler; approval

createInvestmentRequest : Party -> Party -> Party -> Party -> Text -> Date -> ContractId Fund.I -> ContractId Transferable.I -> Update (ContractId InvestmentRequest.I)
createInvestmentRequest operator provider customer public id asOfDate fundCid cashCid = do
  serviceCid <- toInterfaceContractId @InvestmentService.I . fst <$> fetchByKey @InvestmentService.T (operator, provider, customer)
  exercise serviceCid InvestmentService.RequestInvestment with requestId = Id id; asOfDate; fundCid; cashCid

poolInvestmentRequests : Party -> Party -> Party -> Party -> Text -> Date -> ContractId Fund.I -> ContractId Transferable.I -> [ContractId InvestmentRequest.I] -> Update (ContractId PooledInvestmentRequest.I)
poolInvestmentRequests operator provider customer public id asOfDate fundCid cashCid investmentRequestCids = do
  serviceCid <- toInterfaceContractId @FundService.I . fst <$> fetchByKey @FundService.T (operator, provider, customer)
  exercise serviceCid FundService.PoolInvestmentRequests with requestId = Id id; asOfDate; fundCid; cashCid; investmentRequestCids

fulfillPooledInvestmentRequest : Party -> Party -> Party -> Party -> ContractId Fund.I -> ContractId PooledInvestmentRequest.I -> ContractId NumericObservable.I -> Update [ContractId Holding.I]
fulfillPooledInvestmentRequest operator provider customer public fundCid pooledInvestmentRequestCid navObservableCid = do
  serviceCid <- toInterfaceContractId @FundService.I . fst <$> fetchByKey @FundService.T (operator, provider, customer)
  exercise serviceCid FundService.FulfillPooledInvestmentRequest with fundCid; pooledInvestmentRequestCid; navObservableCid
