-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Settlement.Service where

import DA.Set (singleton)
import Daml.Finance.App.Interface.Base.Service qualified as Base (I, View(..))
import Daml.Finance.App.Interface.Settlement.Service qualified as Service (AllocateInstruction(..), ApproveInstruction(..), DiscoverAndInstruct(..), HasImplementation, I, View(..))
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Lifecycle (Claim)
import Daml.Finance.Interface.Settlement.Factory qualified as Factory (I, Instruct(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.RouteProvider qualified as RouteProvider (Discover(..), I)

type T = Service

instance Service.HasImplementation Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    routerCid : ContractId RouteProvider.I
    factoryCid : ContractId Factory.I
    claimRuleCid : ContractId Lifecycle.Claim
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    interface instance Base.I for Service where
      view = Base.View with operator; provider; customer

      terminate = pure ()

    interface instance Service.I for Service where
      view = Service.View with routerCid; factoryCid; claimRuleCid

      asBase = toInterface @Base.I this

      allocateInstruction Service.AllocateInstruction{actor; instructionCid; allocation} = do
        assertMsg "Actor must be provider or customer" $ actor == customer || actor == provider
        fst <$> exercise instructionCid Instruction.Allocate with actors = singleton actor; allocation

      approveInstruction Service.ApproveInstruction{actor; instructionCid; approval} = do
        assertMsg "Actor must be provider or customer" $ actor == customer || actor == provider
        exercise instructionCid Instruction.Approve with actors = singleton actor; approval

      discoverAndInstruct Service.DiscoverAndInstruct{actor; settlers; id; description; contextId; settlementTime; steps} = do
        routedSteps <- exercise routerCid RouteProvider.Discover with discoverors = singleton actor; contextId = None; steps
        exercise factoryCid Factory.Instruct with instructors = singleton actor; settlers; id; description; contextId; settlementTime; routedSteps

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    routerCid : ContractId RouteProvider.I
    factoryCid : ContractId Factory.I
    claimRuleCid : ContractId Lifecycle.Claim
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with operator; provider; customer; routerCid; factoryCid; claimRuleCid

    choice Decline : ()
      controller customer
      do pure ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        routerCid : ContractId RouteProvider.I
        factoryCid : ContractId Factory.I
        claimRuleCid : ContractId Lifecycle.Claim
      controller operator, provider
      do
        create Service with operator; provider; customer; routerCid; factoryCid; claimRuleCid
