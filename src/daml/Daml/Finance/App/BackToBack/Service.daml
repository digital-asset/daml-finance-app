-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.BackToBack.Service where

import DA.List (head)
import DA.Set (fromList, singleton)
import Daml.Finance.App.Distribution.Subscription.Model (BackToBack, Offering(..))
import Daml.Finance.App.Issuance.Model (Issuance(..))
import Daml.Finance.Interface.Holding.Account qualified as Account (Credit(..), K, R)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (Split(..))
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Lockable qualified as Lockable (Acquire(..), I, LockType(..))
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Holding.Util (getAmount)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (Q)
import Daml.Finance.Interface.Settlement.Factory qualified as Factory (I, Instruct(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(Pledge), Approval(TakeDelivery), Step(..))
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I)
import Daml.Finance.Interface.Types.Common (Id(..))

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    public : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice CreateIssuance : (ContractId Issuance, ContractId Holding.I, ContractId Holding.I)
      with
        id : Id
        description : Text
        quantity : Instrument.Q
        customerAccount : Account.K
        providerAccount : Account.K
      controller customer
      do
        (_, customerRef) <- fetchByKey @Account.R customerAccount
        customerHoldingCid <- exercise customerRef.cid Account.Credit with quantity
        (_, providerRef) <- fetchByKey @Account.R providerAccount
        providerHoldingCid <- exercise providerRef.cid Account.Credit with quantity
        providerHoldingCid <- coerceContractId <$> exercise (coerceContractId providerHoldingCid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton provider; observersToAdd = (show id, singleton customer)
        issuanceCid <- create Issuance with operator; provider; customer; id; description; quantity
        pure (issuanceCid, customerHoldingCid, providerHoldingCid)

    nonconsuming choice LockOffering : BackToBack
      with
        backToBack : BackToBack
      controller customer
      do
        b2bDeliverableCid <- coerceContractId <$> exercise (coerceContractId backToBack.b2bDeliverableCid : ContractId Lockable.I) Lockable.Acquire with newLocker = fromList [customer]; context = backToBack.offeringId; lockType = Lockable.Semaphore
        issuerDeliverableCid <- coerceContractId <$> exercise (coerceContractId backToBack.issuerDeliverableCid : ContractId Lockable.I) Lockable.Acquire with newLocker = fromList [provider]; context = backToBack.offeringId; lockType = Lockable.Semaphore
        pure backToBack with b2bDeliverableCid; issuerDeliverableCid

    nonconsuming choice SettleOffering : [ContractId Transferable.I]
      with
        settlementFactoryCid : ContractId Factory.I
        offeringCid : ContractId Offering
        totalQuantity : Decimal
      controller customer
      do
        offering <- fetch offeringCid
        let
          Some b2b = offering.backToBack
          totalNotional = totalQuantity * offering.price.amount
          delivery = Step with sender = b2b.party; receiver = offering.issuer; quantity = (offering.asset with amount = totalQuantity)
          payment = Step with sender = offering.issuer; receiver = b2b.party; quantity = (offering.price with amount = totalNotional)
        (batchCid, [deliveryCid, paymentCid]) <- exercise settlementFactoryCid Factory.Instruct with instructors = singleton customer; settlers = singleton offering.issuer; id = Id offering.offeringId; contextId = None; steps = [ delivery, payment ]; description = "Settlement for offering " <> offering.offeringId

        b2bDeliverable <- fetch b2b.b2bDeliverableCid
        b2bSizedDeliverableCid <-
          if getAmount b2bDeliverable > totalQuantity
          then head . (.splitCids) <$> exercise b2b.b2bDeliverableCid Fungible.Split with amounts = [ totalQuantity ]
          else pure b2b.b2bDeliverableCid
        issuerDeliverable <- fetch b2b.issuerDeliverableCid
        issuerSizedDeliverableCid <-
          if getAmount issuerDeliverable > totalNotional
          then head . (.splitCids) <$> exercise b2b.issuerDeliverableCid Fungible.Split with amounts = [ totalNotional ]
          else pure b2b.issuerDeliverableCid
        deliveryCid <- fst <$> exercise deliveryCid Instruction.Allocate with allocation = Pledge $ coerceContractId b2bSizedDeliverableCid
        deliveryCid <- exercise deliveryCid Instruction.Approve with approval = TakeDelivery b2b.issuerReceivableAccount
        paymentCid <- fst <$> exercise paymentCid Instruction.Allocate with allocation = Pledge $ coerceContractId issuerSizedDeliverableCid
        paymentCid <- exercise paymentCid Instruction.Approve with approval = TakeDelivery b2b.b2bReceivableAccount
        deliveredCids <- exercise batchCid Batch.Settle with actors = singleton customer
        -- mapA (\cid -> coerceContractId <$> exercise (coerceContractId cid : ContractId Lockable.I) Lockable.Release with context = offering.offeringId) deliveredCids
        pure deliveredCids

    choice Terminate : ()
      with
        actor : Party
      controller actor
      do
        assert $ actor == operator || actor == customer || actor == provider
        pure ()

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    public : Party
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with ..

    choice Decline : ()
      controller customer
      do pure ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
    public : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        create Service with ..
