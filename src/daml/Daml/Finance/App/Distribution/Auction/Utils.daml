-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Distribution.Auction.Utils where

import DA.Set (fromList, singleton)
import Daml.Finance.App.Distribution.Bidding.Service qualified as Service (T)
import Daml.Finance.App.Interface.Distribution.Bidding.Service qualified as Service (I, ProcessAllocation(..))
import Daml.Finance.App.Interface.Distribution.Bidding.Bid qualified as Bid (AllocateInstruction(..), Allocation(..), ApproveInstruction(..), I, SettleAllocation(..), View)
import Daml.Finance.App.Interface.Settlement.Service qualified as Settlement (DiscoverAndInstruct(..), Service)
import Daml.Finance.Interface.Holding.Fungible (Fungible, Split(..))
import Daml.Finance.Interface.Holding.Util (getAmount, getInstrument)
import Daml.Finance.Interface.Settlement.Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Batch (Batch)
import Daml.Finance.Interface.Settlement.Types (Allocation(Pledge), Approval(TakeDelivery), Step(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..))
import Daml.Finance.Interface.Util.Common (qty)

-- | Takes a list and splits it based off a predicate.
splitList : (a -> Bool) -> [a] -> [Either a a]
splitList p xs = foldr (\x acc -> if p x then Right x :: acc else Left x :: acc) [] xs

-- -- | Updates a bid's status
-- updateBidStatus : Bidding.Status -> ContractId Bidding.Bid -> Update (ContractId Bidding.Bid)
-- updateBidStatus newStatus bidCid =
--     exercise bidCid Bidding.UpdateStatus with newStatus

-- -- | Reject a bid
-- rejectBid : Bidding.Status -> Bidding.Bid -> Update (ContractId Bidding.Bid, ContractId Transferable)
-- rejectBid newStatus Bidding.Bid{operator, provider, customer, auctionId} = do
--     (bidCid, _) <- fetchByKey @Bidding.Bid (customer, auctionId)
--     exerciseByKey @Bidding.Service (operator, provider, customer) Bidding.RejectAllocation with bidCid; newStatus

-- | A map/accumulator function for processing a submitted bid.
-- Accepts the remaining quantity and price as an accululator along the current Bid as input
-- Output is the updated accululator (if applicable) along with the Bid mapped to an Allocation (depending on the accumulator and bid information)
dutchAuction : (Decimal, Decimal) -> (ContractId Bid.I, Bid.View) -> ((Decimal, Decimal), Bid.Allocation)
dutchAuction acc@(0.0, _)   (bidCid, bid) = (acc, Bid.Allocation with amount = 0.0; bidCid; bid)
dutchAuction (remaining, _) (bidCid, bid) =
  let
    amount = bid.details.quantity.amount
    bidPrice = bid.details.price.amount
  in
    if remaining >= amount
    then ((remaining - amount, bidPrice), Bid.Allocation with amount; bidCid; bid)
    else ((0.0, bidPrice), Bid.Allocation with amount = remaining; bidCid; bid)

-- | An accumulator function which processes generates the settlement instruction for both an issuer and a bidder based of the output of the dutch auction
generateSettlementInstruction : ContractId Settlement.Service -> Party -> AccountKey -> (Optional (ContractId Fungible), [ContractId Batch]) -> Bid.SettleAllocation -> Update (Optional (ContractId Fungible), [ContractId Batch])
generateSettlementInstruction _ _ _ (None, _) _ = error "Auction:generateSettlementInstruction - Issuers AssetDeposit has no remaining units to allocate"
generateSettlementInstruction settlementServiceCid settler issuerAccount (Some issuerDepositCid, batchCids) Bid.SettleAllocation{allocation, price, issuer} = do
  let
    allocatedAmount = allocation.amount
    allocatedNotional = allocation.amount * price

  -- | Process bid side
  bid <- view <$> fetch allocation.bidCid
  (serviceCid, _) <- fetchByKey @Service.T (bid.operator, bid.provider, bid.customer)
  (bidCid, bidDepositCid) <- exercise (toInterfaceContractId @Service.I serviceCid) Service.ProcessAllocation with bidCid = allocation.bidCid; amount = allocatedAmount; price
  let
    buyer = bid.customer
    payment = Step with sender = bid.customer; receiver = issuer; quantity = (qty allocatedNotional bid.details.price.unit)

  -- | Process issuer side
  -- 1/ Extract their deposit
  -- 2/ Split allocation quantity from this deposit, get the deposit matching the allocation. Can only result in either :
      -- two asset deposits - One with the allocation, one with the remaining
      -- one asset deposit - Occurs when processing the last bid when the auction is fully allocated
  -- 3/ Create the settlement details for delivery of the asset to the buyer
  splitResult <- exercise issuerDepositCid Split with amounts = [allocatedAmount]
  let
    seller = issuer
    [allocatedDepositCid] = splitResult.splitCids
  allocatedDeposit <- fetch allocatedDepositCid
  let
    delivery = Step with sender = issuer; receiver = buyer; quantity = (qty (getAmount allocatedDeposit) (getInstrument allocatedDeposit))
    id = show bid.auctionId <> "-" <> partyToText buyer

  (batchCid, [deliveryCid, paymentCid]) <- exercise settlementServiceCid Settlement.DiscoverAndInstruct with
    actor = settler
    settlers = singleton settler
    id = Id id
    description = "Settlement of auction " <> id
    contextId = Some $ Id id
    settlementTime = None
    steps = [delivery, payment]
  deliveryCid <- fst <$> exercise deliveryCid Allocate with actors = singleton issuer; allocation = Pledge $ toInterfaceContractId allocatedDepositCid
  exercise bidCid Bid.ApproveInstruction with instructionCid = deliveryCid; account = bid.receivableAccount
  paymentCid <- exercise bidCid Bid.AllocateInstruction with instructionCid = paymentCid; holdingCid = bidDepositCid
  exercise paymentCid Approve with actors = fromList [issuer]; approval = TakeDelivery issuerAccount

  pure (splitResult.rest, batchCid :: batchCids)
