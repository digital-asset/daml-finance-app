-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Distribution.Fund.Service where

import DA.Foldable (mapA_)
import DA.List (dedup)
import DA.Map qualified as M (lookup)
import DA.Optional (fromSome)
import DA.Set (singleton)
import DA.Time (time)
import Daml.Finance.App.Data.AccountDirectory (AccountDirectory)
import Daml.Finance.App.Distribution.Fund.Model qualified as Model (PooledInvestmentRequest(..))
import Daml.Finance.App.Interface.Common.Removable qualified as Removable (I, Remove(..))
import Daml.Finance.App.Interface.Base.Service qualified as Base (I, View(..))
import Daml.Finance.App.Interface.Distribution.Fund.Fund qualified as Fund (ApproveInstruction(..), GetView(..), IssueUnits(..))
import Daml.Finance.App.Interface.Distribution.Fund.Service qualified as Service (FulfillPooledInvestmentRequest(..), HasImplementation, I, PoolInvestmentRequests(..), View(..))
import Daml.Finance.App.Interface.Distribution.Investment.InvestmentRequest qualified as InvestmentRequest (AllocateInstruction(..), ApproveInstruction(..))
import Daml.Finance.App.Interface.Settlement.Service qualified as SettlementService (DiscoverAndInstruct(..), I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I)
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (Observe(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(..), Approval(..), Step(..))
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I)

type T = Service

instance Service.HasImplementation Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    settlementServiceCid : ContractId SettlementService.I
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    interface instance Base.I for Service where
      view = Base.View with operator; provider; customer

      terminate = pure ()

    interface instance Service.I for Service where
      view = Service.View with settlementServiceCid

      asBase = toInterface @Base.I this

      poolInvestmentRequests Service.PoolInvestmentRequests{requestId; asOfDate; fundCid; cashCid; investmentRequestCids} = do
        fund <- exercise fundCid Fund.GetView with actor = customer
        irs <- mapA (fmap view . fetch) investmentRequestCids
        (_, dir) <- fetchByKey @AccountDirectory customer

        -- Disclose cash to provider
        cashCid : ContractId Transferable.I <- coerceContractId <$> exercise (coerceContractId cashCid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (show requestId, singleton provider)
        -- cash <- fetch cashCid
        -- Account.disclose (show requestId, singleton provider) customer (singleton customer) $ getAccount cash

        let
          [currency] = dedup $ map (.quantity.unit) irs
          [fundId] = dedup $ map (.fundId) irs
          [asOfDate] = dedup $ map (.asOfDate) irs
          total = sum $ map (.quantity.amount) irs
          quantity = qty total currency
          customerFundAccount = fromSome $ M.lookup fund.instrument.id dir.accounts
        toInterfaceContractId <$> create Model.PooledInvestmentRequest with operator; provider; customer; requestId; asOfDate; fundId; quantity; cashCid; investmentRequestCids; customerFundAccount

      fulfillPooledInvestmentRequest Service.FulfillPooledInvestmentRequest{pooledInvestmentRequestCid; fundCid; navObservableCid} = do
        pir <- view <$> fetch pooledInvestmentRequestCid
        fund <- view <$> fetch fundCid

        -- Calculate nr of units to issue
        nav <- exercise navObservableCid NumericObservable.Observe with actors = singleton customer; t = time pir.asOfDate 0 0 0
        let
          unitValue = nav / fund.totalUnits
          nrUnits = pir.quantity.amount / unitValue
          fundQty = qty nrUnits fund.instrument

        -- Issue units
        (fundUnitsCid, fundCid) <- exercise fundCid Fund.IssueUnits with requestId = pir.requestId; quantity = fundQty

        -- Instruct settlement
        irs <- mapA (fmap view . fetch) pir.investmentRequestCids
        let
          createInvestorCashStep ir = Step with sender = ir.customer; receiver = ir.provider; quantity = ir.quantity
          createInvestorFundStep ir = Step with sender = ir.provider; receiver = ir.customer; quantity = qty (ir.quantity.amount / unitValue) fund.instrument
          custodianCashStep = Step with sender = pir.customer; receiver = fund.custodian; quantity = pir.quantity
          managerFundStep = Step with sender = provider; receiver = pir.customer; quantity = fundQty
          steps = custodianCashStep :: managerFundStep :: map createInvestorCashStep irs <> map createInvestorFundStep irs
        (batchCid, custodianCashInstructionCid :: managerFundInstructionCid :: investorInstructionCids) <- exercise settlementServiceCid SettlementService.DiscoverAndInstruct with
          actor = provider
          settlers = singleton provider
          id = pir.requestId
          description = "Settlement for " <> show pir.requestId
          contextId = Some pir.requestId
          settlementTime = None
          steps

        let
          reqInst = zip (pir.investmentRequestCids <> pir.investmentRequestCids) investorInstructionCids
          (reqInstCash, reqInstFund) = splitAt (length irs) reqInst

        -- Allocate and approve custodian cash instruction
        (custodianCashInstructionCid, _) <- exercise custodianCashInstructionCid Instruction.Allocate with actors = singleton provider; allocation = Pledge $ toInterfaceContractId pir.cashCid
        exercise fundCid Fund.ApproveInstruction with instructionCid = custodianCashInstructionCid

        -- Allocate and approve manager fund instruction
        (managerFundInstructionCid, _) <- exercise managerFundInstructionCid Instruction.Allocate with actors = singleton provider; allocation = Pledge $ coerceContractId fundUnitsCid
        exercise managerFundInstructionCid Instruction.Approve with actors = singleton provider; approval = TakeDelivery pir.customerFundAccount

        -- Allocate and approve investor instructions
        let
          processCash (irCid, iCid) = do
            iCid <- exercise irCid InvestmentRequest.AllocateInstruction with instructionCid = iCid
            exercise iCid Instruction.Approve with actors = singleton provider; approval = DebitSender
          processFund (irCid, iCid) = do
            (iCid, _) <- exercise iCid Instruction.Allocate with actors = singleton provider; allocation = CreditReceiver
            exercise irCid InvestmentRequest.ApproveInstruction with instructionCid = iCid
        mapA_ processCash reqInstCash
        mapA_ processFund reqInstFund

        mapA_ (\cid -> exercise (toInterfaceContractId @Removable.I cid) Removable.Remove) pir.investmentRequestCids
        exercise (toInterfaceContractId @Removable.I pooledInvestmentRequestCid) Removable.Remove
        exercise batchCid Batch.Settle with actors = singleton provider

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    settlementServiceCid : ContractId SettlementService.I
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with operator; provider; customer; settlementServiceCid

    choice Decline : ()
      controller customer
      do
        return ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    provider : Party
    customer : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        settlementServiceCid : ContractId SettlementService.I
      controller operator, provider
      do
        create Service with operator; provider; customer; settlementServiceCid
