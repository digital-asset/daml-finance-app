-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE MultiWayIf #-}

module Daml.Finance.App.Distribution.PrivateEquity.Service where

import DA.Action (foldlA)
import DA.Either (partitionEithers)
import DA.Foldable (forA_)
import DA.List (sortOn, mapAccumL)
import DA.Optional (whenSome)
import DA.Set (fromList, singleton)
import Daml.Finance.App.Distribution.PrivateEquity.Model (PrivateEquity(..), CreatePrivateEquityRequest(..), Status(..))
import Daml.Finance.App.Distribution.PrivateEquity.Utils (dutchAuction, splitList, generateSettlementInstruction)
import Daml.Finance.App.Distribution.Bidding.Model qualified as Bidding (Allocation(..), Bid, SettleAllocation(..), Status(..))
import Daml.Finance.App.Distribution.Bidding.Service qualified as Bidding (RejectBid(..), S)
import Daml.Finance.App.Settlement.Service qualified as Settlement (Service)
import Daml.Finance.App.Util (fetchAndArchive)
import Daml.Finance.Interface.Account.Account qualified as Account (R, exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Base qualified as Holding (Acquire(..), I, LockType(..), Release(..))
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Account.Util (getAccount)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I, RemoveObservers(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, InstrumentKey, InstrumentQuantity, Parties)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))

type S = Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    settlementServiceCid : ContractId Settlement.Service
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice RequestCreatePrivateEquity : ContractId CreatePrivateEquityRequest
      with
        id : Text
        quantity : InstrumentQuantity
        currency : InstrumentKey
        floor : Decimal
        collateralCid : ContractId Fungible.I
        receivableAccount : AccountKey
        observers : Parties
      controller customer
      do
        -- Disclose holding
        collateral <- fetch collateralCid
        collateralCid <- coerceContractId <$> exercise (coerceContractId collateralCid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (id, fromList [provider])

        -- Disclose delivering securities account
        (_, delRef) <- fetchByKey @Account.R $ getAccount collateral
        exercise (coerceContractId delRef.cid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (id, fromList [provider])

        -- Disclose receiving cash account
        (_, recRef) <- fetchByKey @Account.R receivableAccount
        exercise (coerceContractId recRef.cid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (id, singleton provider)

        create CreatePrivateEquityRequest with operator; provider; customer; id; quantity; currency; floor; collateralCid; receivableAccount; observers

    nonconsuming choice CancelPrivateEquityRequest : ()
      with
        createPrivateEquityRequestCid : ContractId CreatePrivateEquityRequest
      controller customer
      do
        archive createPrivateEquityRequestCid

    nonconsuming choice CreatePrivateEquity : ContractId PrivateEquity
      with
        createPrivateEquityRequestCid : ContractId CreatePrivateEquityRequest
      controller provider
      do
        CreatePrivateEquityRequest{id; quantity; currency; floor; collateralCid; receivableAccount; observers} <- fetchAndArchive createPrivateEquityRequestCid
        collateralCid <- coerceContractId <$> exercise (toInterfaceContractId collateralCid : ContractId Holding.I) Holding.Acquire with newLockers = fromList [ provider ]; context = id; lockType = Holding.Semaphore
        create PrivateEquity with operator; provider; customer; id; quantity; currency; floor; collateralCid; receivableAccount; status = Open; observers

    nonconsuming choice RejectPrivateEquity : ()
      with
        createPrivateEquityRequestCid : ContractId CreatePrivateEquityRequest
      controller provider
      do
        archive createPrivateEquityRequestCid

    nonconsuming choice ProcessPrivateEquity : ContractId PrivateEquity
      with
        privateEquityCid : ContractId PrivateEquity
        bidCids : [ContractId Bidding.Bid]
      controller provider
      do
        privateEquity <- fetch privateEquityCid
        collateral <- fetch privateEquity.collateralCid
        bids <- zip bidCids <$> forA bidCids fetch
        collaterals <- mapA (fetch . (.collateralCid) . snd) bids
        assertMsg "PrivateEquity already successfully processed" (privateEquity.status `elem` [Open, NoValidBids])

        -- Split bids on those above / below the floor price -> Sort valid bids descendingly -> Execute PrivateEquity -> Split PrivateEquity result on allocated / unallocated (ie, zero allocation)
        let
          collateralAccount = getAccount collateral
          collateralAccounts = map getAccount collaterals
          receivableAccounts = map ((.receivableAccount) . snd) bids
          (invalidBids, validBids) = partitionEithers $ splitList (\(_, bid) -> bid.details.price.amount >= privateEquity.floor) bids
          sortedBids = sortOn (\(_, bid) -> Down bid.details) validBids
          ((remaining, finalPrice), allocations) = mapAccumL dutchAuction (privateEquity.quantity.amount, 0.0) sortedBids
          (allocatedBids, unallocatedBids) = partitionEithers $ splitList (\allocation -> allocation.amount == 0.0) allocations

        -- Return assets of all invalid and unallocated bids. Also update their bid status accordingly
        forA_ invalidBids (\(bidCid, bid) -> exerciseByKey @Bidding.S (bid.operator, bid.provider, bid.customer) Bidding.RejectBid with bidCid; newStatus = Bidding.Invalid)
        forA_ unallocatedBids (\Bidding.Allocation{bidCid, bid} -> exerciseByKey @Bidding.S (bid.operator, bid.provider, bid.customer) Bidding.RejectBid with bidCid; newStatus = Bidding.NoAllocation)

        -- Unlock PrivateEquity collateral
        privateEquityCollateralClid <- coerceContractId <$> exercise (toInterfaceContractId privateEquity.collateralCid : ContractId Holding.I) Holding.Release with context = privateEquity.id

        -- Generate Settlement instructions for allocated bids
        let settleAllocations = (\allocation -> Bidding.SettleAllocation with allocation; price = finalPrice; issuer = customer) <$> allocatedBids
        (remainingDepositCidOpt, batchCids) <- foldlA (generateSettlementInstruction settlementServiceCid provider privateEquity.receivableAccount) (Some privateEquityCollateralClid, []) settleAllocations

        -- Settle transfers
        forA_ batchCids (`exercise` Batch.Settle with actors = singleton provider)

        -- Undisclose unallocated deposit
        whenSome remainingDepositCidOpt \depositCid -> do
          exercise (coerceContractId depositCid : ContractId Disclosure.I) Disclosure.RemoveObservers with disclosers = singleton customer; observersToRemove = (privateEquity.id, singleton provider)
          pure ()

        -- Undisclose accounts
        Account.exerciseInterfaceByKey @Disclosure.I privateEquity.receivableAccount provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (privateEquity.id, singleton provider)
        Account.exerciseInterfaceByKey @Disclosure.I collateralAccount provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (privateEquity.id, singleton provider)
        forA_ receivableAccounts (\a -> Account.exerciseInterfaceByKey @Disclosure.I a provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (privateEquity.id, singleton provider))
        forA_ collateralAccounts (\a -> Account.exerciseInterfaceByKey @Disclosure.I a provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (privateEquity.id, singleton provider))

        -- Update PrivateEquity contract with the outcome of the privateEquity processing
        let newStatus = if
              | remaining == privateEquity.quantity.amount -> NoValidBids
              | remaining > 0.0 -> PartiallyAllocated with finalPrice; remaining
              | otherwise -> FullyAllocated with finalPrice
        archive privateEquityCid
        create privateEquity with status = newStatus

    choice Terminate : ()
      with
        actor : Party
      controller actor
      do
        assert $ actor == operator || actor == provider || actor == customer
        pure ()

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    settlementServiceCid : ContractId Settlement.Service
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with operator; provider; customer; settlementServiceCid

    choice Decline : ()
      controller customer
      do
        return ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    provider : Party
    customer : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        settlementServiceCid : ContractId Settlement.Service
      controller operator, provider
      do
        create Service with operator; provider; customer; settlementServiceCid
