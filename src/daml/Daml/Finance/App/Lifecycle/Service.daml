-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Lifecycle.Service where

import ContingentClaims.Core.Claim (Claim)
import ContingentClaims.Core.Observation (Observation(..))
import ContingentClaims.Lifecycle.Lifecycle qualified as Lifecycle
import ContingentClaims.Lifecycle.Util (expiry, fixings, payoffs)
import ContingentClaims.Valuation.Stochastic (Expr)
import Daml.Finance.Claims.Util.Lifecycle qualified as Claim (lifecycle, lifecycleClaims, timeEvent)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (I, R)
import Daml.Finance.Interface.Instrument.Equity.Instrument qualified as Equity (I, DeclareDividend(..), DeclareReplacement(..), DeclareStockSplit(..))
import Daml.Finance.Instrument.PrivateEquity.Instrument qualified as PrivateEquity (T)
import Daml.Finance.Interface.Claims.Claim qualified as Claim (Claim, getClaims, GetClaims(..))
import Daml.Finance.Interface.Claims.Types (C, Pending, TaggedClaim)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I)
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I, Evolve(..))
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I)
import Daml.Finance.Interface.Types.Common.Types (Quantity(..), Id, InstrumentKey(..), InstrumentQuantity)
import Daml.Finance.App.Lifecycle.Pricing qualified as Pricing
import Daml.Finance.App.Structuring.Auto.Service qualified as Structuring

import Daml.Finance.Setup.Payoff (capitalCall)

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    distributionRuleCid : ContractId Lifecycle.I
    replacementRuleCid : ContractId Lifecycle.I
    genericRuleCid : ContractId Lifecycle.I
    dynamicRuleCid : ContractId Lifecycle.I
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice DeclareDividend : [ContractId Effect.I]
      with
        equity : InstrumentKey
        newVersion : Text
        id : Id
        description : Text
        effectiveTime : Time
        perUnitDistribution : [ InstrumentQuantity ]
      controller customer
      do
        now <- getTime
        (_, equityRef) <- fetchByKey @Instrument.R equity
        equityInstrument <- fetch equityRef.cid
        let
          disclosure = toInterface @Disclosure.I equityInstrument
          v = view equityInstrument
          dv = view disclosure
          newInstrument = InstrumentKey with depository = provider; issuer = customer; id = equity.id; version = newVersion
        exerciseByKey @Structuring.Service (operator, provider, customer) Structuring.RequestAndCreateEquity with id = equity.id; description = v.description; version = newVersion; validAsOf = now; observers = dv.observers
        eventCid <- exercise (coerceContractId equityRef.cid : ContractId Equity.I) Equity.DeclareDividend with id; description; effectiveTime; newInstrument; perUnitDistribution
        snd <$> exercise distributionRuleCid Lifecycle.Evolve with
          eventCid
          instrument = equity
          observableCids = []

    nonconsuming choice DeclareCapitalCall : [ContractId Effect.I]
      with
        privateEquity : InstrumentKey
        newVersion : Text
        id : Id
        description : Text
        effectiveTime : Time
        amount: Numeric 10
      controller customer
      do
        now <- getTime
        (_, peRef) <- fetchByKey @Instrument.R privateEquity 
        peInstrument <- fetch (coerceContractId peRef.cid: ContractId PrivateEquity.T)

        let
          disclosure = toInterface @Disclosure.I peInstrument
          dv = view disclosure
          newInstrument = InstrumentKey with depository = provider; issuer = customer; id = privateEquity.id; version = newVersion
          newLiabilityInstrument = InstrumentKey with depository = provider; issuer = customer; id = privateEquity.id; version = "0"
          antiDividend = Quantity 
            with 
              unit = peInstrument.callInstrument 
              amount 

        exerciseByKey @Structuring.Service (operator, provider, customer) Structuring.RequestAndCreatePrivateEquity 
          with 
            id = privateEquity.id
            description = peInstrument.description
            version = newVersion
            validAsOf = now
            observers = dv.observers
            callInstrument = peInstrument.callInstrument
            called = peInstrument.called + amount

        eventCid <- exercise (coerceContractId peRef.cid : ContractId Equity.I) Equity.DeclareDividend with id; description; effectiveTime; newInstrument; perUnitDistribution=[antiDividend]
        snd <$> exercise distributionRuleCid Lifecycle.Evolve with
          eventCid
          instrument = privateEquity
          observableCids = []

    nonconsuming choice DeclareReplacement : [ContractId Effect.I]
      with
        equity : InstrumentKey
        id : Id
        description : Text
        effectiveTime : Time
        perUnitReplacement : [InstrumentQuantity]
      controller customer
      do
        (_, equityRef) <- fetchByKey @Instrument.R equity
        eventCid <- exercise (coerceContractId equityRef.cid : ContractId Equity.I) Equity.DeclareReplacement with id; description; effectiveTime; perUnitReplacement
        snd <$> exercise replacementRuleCid Lifecycle.Evolve with
          eventCid
          instrument = equity
          observableCids = []

    nonconsuming choice DeclareStockSplit : [ContractId Effect.I]
      with
        equity : InstrumentKey
        newVersion : Text
        id : Id
        description : Text
        effectiveTime : Time
        adjustmentFactor : Decimal
      controller customer
      do
        now <- getTime
        (_, equityRef) <- fetchByKey @Instrument.R equity
        equityInstrument <- fetch equityRef.cid
        let
          disclosure = toInterface @Disclosure.I equityInstrument
          v = view equityInstrument
          dv = view disclosure
          newInstrument = InstrumentKey with depository = provider; issuer = customer; id = v.id; version = newVersion
        exerciseByKey @Structuring.Service (operator, provider, customer) Structuring.RequestAndCreateEquity with id = v.id; description = v.description; version = newVersion; validAsOf = now; observers = dv.observers
        eventCid <- exercise (coerceContractId equityRef.cid : ContractId Equity.I) Equity.DeclareStockSplit with id; description; effectiveTime; newInstrument; adjustmentFactor
        snd <$> exercise replacementRuleCid Lifecycle.Evolve with
          eventCid
          instrument = equity
          observableCids = []

    nonconsuming choice PreviewLifecycle : ([TaggedClaim], [Pending])
      with
        today : Time
        observableCids : [ContractId NumericObservable.I]
        instrumentCid : ContractId Claim.Claim
      controller customer
      do
        instrument <- fetch instrumentCid
        claims <- exercise self GetCurrentClaims with instrumentCid; observableCids
        Claim.lifecycleClaims observableCids ((view instrument).acquisitionTime) claims [Claim.timeEvent today]

    nonconsuming choice SimulateLifecycle : [[Lifecycle.Pending Time InstrumentKey]]
      with
        today : Time
        prices : [Decimal]
        instrumentCid : ContractId Claim.Claim
      controller customer
      do
        instrument <- fetch instrumentCid
        taggedClaims <- Claim.getClaims instrument $ Claim.GetClaims with actor = customer
        let
          claim = mconcat $ map (.claim) taggedClaims
          simulate price = do
            result <- Lifecycle.lifecycle (\_ t -> pure price) claim today today
            pure result.pending
        mapA simulate prices

    nonconsuming choice GetCurrentClaims : [TaggedClaim]
      with
        instrumentCid : ContractId Claim.Claim
        observableCids : [ContractId NumericObservable.I]
      controller customer
      do
        hasClaims <- fetch instrumentCid
        instrument <- fetch (coerceContractId instrumentCid : ContractId Instrument.I)
        fst <$> Claim.lifecycle customer observableCids hasClaims [Claim.timeEvent (view instrument).validAsOf]

    nonconsuming choice Lifecycle : (Optional InstrumentKey, [ContractId Effect.I])
      with
        eventCid : ContractId Event.I
        instrument : InstrumentKey
        observableCids : [ContractId NumericObservable.I]
        ruleCid : ContractId Lifecycle.I
      controller customer
      do
        exercise ruleCid Lifecycle.Evolve with eventCid; observableCids; instrument

    nonconsuming choice Expiry : Optional Time
      with
        claims : C
      controller customer
      do
        pure $ expiry claims

    nonconsuming choice Underlying : [InstrumentKey]
      with
        claims : C
      controller customer
        do
          pure $ snd <$> payoffs claims

    nonconsuming choice Payoffs : [(Observation Time Decimal Text, InstrumentKey)]
      with
        claims : C
      controller customer
        do
          pure $ payoffs claims

    nonconsuming choice Fixings : [Time]
      with
        claims : C
      controller customer
        do
          pure $ fixings claims

    nonconsuming choice Multipliers : [Decimal]
      with
        claims : C
      controller customer
        do
          let getConst : (Observation Time Decimal a, b) -> [Decimal]
              getConst (Const x, _) = [x]
              getConst _            = []
          return $ concatMap getConst $ payoffs claims

    nonconsuming choice PreviewPricing : (Expr Text, Text)
      with
        ccy : Text
        claims : Claim Text Decimal Text Text
      controller customer
      do
        let formula = Pricing.valueClaim ccy claims
        pure (formula, Pricing.print formula)

    choice Terminate : ()
      with
        actor : Party
      controller actor
      do
        assert $ actor == operator || actor == provider || actor == customer
        pure ()

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    distributionRuleCid : ContractId Lifecycle.I
    replacementRuleCid : ContractId Lifecycle.I
    genericRuleCid : ContractId Lifecycle.I
    dynamicRuleCid : ContractId Lifecycle.I
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with ..

    choice Decline : ()
      controller customer
      do pure ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        distributionRuleCid : ContractId Lifecycle.I
        replacementRuleCid : ContractId Lifecycle.I
        genericRuleCid : ContractId Lifecycle.I
        dynamicRuleCid : ContractId Lifecycle.I
      controller operator, provider
      do
        create Service with ..
