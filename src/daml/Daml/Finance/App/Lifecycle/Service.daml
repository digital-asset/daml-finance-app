-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Lifecycle.Service where

import ContingentClaims.Claim (Claim)
import ContingentClaims.Lifecycle qualified as Lifecycle
import ContingentClaims.Math.Stochastic (Expr)
import ContingentClaims.Observation (Observation(..))
import ContingentClaims.Util (expiry, fixings, payoffs)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (I, K, Q)
import Daml.Finance.Interface.Instrument.Equity.Instrument qualified as Equity (I, DeclareDividend(..))
import Daml.Finance.Interface.Instrument.Generic.HasClaims qualified as Generic (HasClaims, getClaims)
import Daml.Finance.Interface.Instrument.Generic.Types (C, Pending, TaggedClaim)
import Daml.Finance.Interface.Instrument.Generic.Util.Claims.Lifecycle qualified as Generic (lifecycle, lifecycleClaims, timeEvent)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
import Daml.Finance.Interface.Lifecycle.Clock qualified as Clock (I)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I)
import Daml.Finance.Interface.Lifecycle.Observable qualified as Observable (I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I, Evolve(..))
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I)
import Daml.Finance.Interface.Types.Common (Id, InstrumentKey(..))
import Daml.Finance.App.Lifecycle.Pricing qualified as Pricing
import Daml.Finance.App.Structuring.Auto.Service qualified as Structuring

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    distributionRuleCid : ContractId Lifecycle.I
    replacementRuleCid : ContractId Lifecycle.I
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice DeclareDividend : [ContractId Effect.I]
      with
        clockCid : ContractId Clock.I
        equityCid : ContractId Equity.I
        newVersion : Text
        id : Id
        description : Text
        effectiveDate : Date
        perUnitDistribution : [ Instrument.Q ]
      controller customer
      do
        equity <- fetch equityCid
        let
          instrument = toInterface @Instrument.I equity
          disclosure = toInterface @Disclosure.I instrument
          v = view instrument
          dv = view disclosure
          newInstrument = InstrumentKey with depository = provider; issuer = customer; id = v.id; version = newVersion
        newEquityCid <- exerciseByKey @Structuring.Service (operator, provider, customer) Structuring.RequestAndCreateEquity with id = v.id; description = v.description; version = newVersion; validAsOf = v.validAsOf; observers = dv.observers
        eventCid <- exercise equityCid Equity.DeclareDividend with id; description; effectiveDate; newInstrument; perUnitDistribution
        snd <$> exercise distributionRuleCid Lifecycle.Evolve with ruleName = "Dividend"; settler = provider; eventCid; clockCid; observableCids = []

    nonconsuming choice PreviewLifecycle : ([TaggedClaim], [Pending])
      with
        today : Time
        observableCids : [ContractId Observable.I]
        instrumentCid : ContractId Generic.HasClaims
      controller customer
      do
        instrument <- fetch instrumentCid
        claims <- exercise self GetCurrentClaims with instrumentCid; observableCids
        Generic.lifecycleClaims observableCids ((view instrument).acquisitionTime) claims [Generic.timeEvent today]

    nonconsuming choice SimulateLifecycle : [[Lifecycle.Pending Time Instrument.K]]
      with
        today : Time
        prices : [Decimal]
        instrumentCid : ContractId Generic.HasClaims
      controller customer
      do
        instrument <- fetch instrumentCid
        claims <- mconcat . map (.claim) <$> Generic.getClaims instrument
        let
          simulate price = do
            result <- Lifecycle.lifecycle (\_ t -> pure price) claims today today
            pure result.pending
        mapA simulate prices

    nonconsuming choice GetCurrentClaims : [TaggedClaim]
      with
        instrumentCid : ContractId Generic.HasClaims
        observableCids : [ContractId Observable.I]
      controller customer
      do
        hasClaims <- fetch instrumentCid
        instrument <- fetch (coerceContractId instrumentCid : ContractId Instrument.I)
        fst <$> Generic.lifecycle observableCids hasClaims [Generic.timeEvent (view instrument).validAsOf]

    nonconsuming choice Lifecycle : (ContractId Lifecycle.I, [ContractId Effect.I])
      with
        ruleName : Text
        eventCid : ContractId Event.I
        clockCid : ContractId Clock.I
        observableCids : [ContractId Observable.I]
        lifecyclableCid : ContractId Lifecycle.I
      controller customer
      do
        exercise lifecyclableCid Lifecycle.Evolve with ruleName; settler = provider; eventCid; clockCid; observableCids

    nonconsuming choice Expiry : Optional Time
      with
        claims : C
      controller customer
      do
        pure $ expiry claims

    nonconsuming choice Underlying : [Instrument.K]
      with
        claims : C
      controller customer
        do
          pure $ snd <$> payoffs claims

    nonconsuming choice Payoffs : [(Observation Time Decimal Text, Instrument.K)]
      with
        claims : C
      controller customer
        do
          pure $ payoffs claims

    nonconsuming choice Fixings : [Time]
      with
        claims : C
      controller customer
        do
          pure $ fixings claims

    nonconsuming choice Multipliers : [Decimal]
      with
        claims : C
      controller customer
        do
          let getConst : (Observation Time Decimal a, b) -> [Decimal]
              getConst (Const x, _) = [x]
              getConst _            = []
          return $ concatMap getConst $ payoffs claims

    nonconsuming choice PreviewPricing : (Expr Text, Text)
      with
        ccy : Text
        claims : Claim Text Decimal Text Text
      controller customer
      do
        let formula = Pricing.valueClaim ccy claims
        pure (formula, Pricing.print formula)

    choice Terminate : ()
      with
        actor : Party
      controller actor
      do
        assert $ actor == operator || actor == provider || actor == customer
        pure ()

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    distributionRuleCid : ContractId Lifecycle.I
    replacementRuleCid : ContractId Lifecycle.I
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with ..

    choice Decline : ()
      controller customer
      do pure ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        distributionRuleCid : ContractId Lifecycle.I
        replacementRuleCid : ContractId Lifecycle.I
      controller operator, provider
      do
        create Service with ..
