-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Lifecycle.Service where

import ContingentClaims.Core.Claim (Claim)
import ContingentClaims.Core.Observation (Observation(..))
import ContingentClaims.Lifecycle.Lifecycle qualified as Lifecycle
import ContingentClaims.Lifecycle.Util (expiry, fixings, payoffs)
import ContingentClaims.Valuation.Stochastic (Expr)
import Daml.Finance.Claims.Util.Lifecycle qualified as Claim (lifecycle, lifecycleClaims, timeEvent, splitPending)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (I, R)
import Daml.Finance.Interface.Instrument.Equity.Instrument qualified as Equity (I, DeclareDividend(..), DeclareReplacement(..), DeclareStockSplit(..))
import Daml.Finance.Instrument.PrivateEquity.Instrument qualified as PrivateEquity (T)
import Daml.Finance.Interface.Claims.Claim qualified as Claim (Claim, I, getClaims, GetClaims(..))
import Daml.Finance.Interface.Claims.Types (C, Pending, TaggedClaim)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I, Effect)
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I)
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I, Evolve(..))
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I)
import Daml.Finance.Interface.Types.Common.Types (Quantity(..), Id, InstrumentKey(..), InstrumentQuantity)
import Daml.Finance.Instrument.Generic.Election qualified as Election (Election(..))
import Daml.Finance.Interface.Instrument.Generic.Election qualified as Election (ApplyElection(..), Exercisable(..), ExercisableView(..), getElectionTime)
import Daml.Finance.App.Lifecycle.Pricing qualified as Pricing
import Daml.Finance.App.Structuring.Auto.Service qualified as Structuring
import Daml.Finance.Claims.Util.Lifecycle (electionEvent)

import Daml.Finance.Interface.Instrument.Base.Instrument qualified as BaseInstrument (R, createReference, getKey)
import Daml.Finance.Instrument.Generic.Instrument (Instrument(..))
import Daml.Finance.Lifecycle.ElectionEffect (ElectionEffect(..))
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import DA.Foldable (forA_)
import DA.Optional (fromSome)
import DA.Set (fromList)
import DA.Text (sha256)
import Daml.Finance.Claims.Util (isZero')

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    distributionRuleCid : ContractId Lifecycle.I
    replacementRuleCid : ContractId Lifecycle.I
    genericRuleCid : ContractId Lifecycle.I
    dynamicRuleCid : ContractId Lifecycle.I
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice DeclareDividend : [ContractId Effect.I]
      with
        equity : InstrumentKey
        newVersion : Text
        id : Id
        description : Text
        effectiveTime : Time
        perUnitDistribution : [ InstrumentQuantity ]
      controller customer
      do
        now <- getTime
        (_, equityRef) <- fetchByKey @Instrument.R equity
        equityInstrument <- fetch equityRef.cid
        let
          disclosure = toInterface @Disclosure.I equityInstrument
          v = view equityInstrument
          dv = view disclosure
          newInstrument = InstrumentKey with depository = provider; issuer = customer; id = equity.id; version = newVersion
        exerciseByKey @Structuring.Service (operator, provider, customer) Structuring.RequestAndCreateEquity with id = equity.id; description = v.description; version = newVersion; validAsOf = now; observers = dv.observers
        eventCid <- exercise (coerceContractId equityRef.cid : ContractId Equity.I) Equity.DeclareDividend with id; description; effectiveTime; newInstrument; perUnitDistribution
        snd <$> exercise distributionRuleCid Lifecycle.Evolve with
          eventCid
          instrument = equity
          observableCids = []

    nonconsuming choice DeclareCapitalCall: [ContractId Effect.I] 
      with 
        id: Id 
        description: Text 
        electionTime: Time 
        amount: Decimal 
        commitment: InstrumentKey 
        claim: C
      controller customer 
      do 
        (_, commitmentRef) <- fetchByKey @Instrument.R commitment 
        commitmentInstrument <- fetch commitmentRef.cid 
        let 
          disclosure = toInterface @Disclosure.I commitmentInstrument 
          cv = view commitmentInstrument 
          dv = view disclosure
          electorIsOwner = True
          instrument = commitment
          elector = customer
          counterparty = provider
          election = Election.Election
            with 
              elector 
              counterparty 
              provider 
              id 
              description 
              instrument 
              amount 
              claim 
              electorIsOwner 
              electionTime 
              observers = dv.observers
          --electionTime = Election.getElectionTime election
          election = electionEvent electionTime electorIsOwner claim
          lifecycler = customer

        -- fetch claim tree
        claimInstrument <- fetchInterfaceByKey @BaseInstrument.R instrument
        claims <- Claim.getClaims (toInterface @Claim.I claimInstrument) $ Claim.GetClaims with
          actor = lifecycler

        -- lifecycle as of the time given by the event, by applying the corresponding election
        (remaining, pending) <- Claim.lifecycle lifecycler [] claimInstrument [election]

        -- create new instrument and return effect
        if remaining == claims && null pending then
          pure []
        else do
          let
            instrumentT : Instrument = fromSome $ fromInterface claimInstrument
            currentKey = BaseInstrument.getKey $ toInterface claimInstrument
            newKey = currentKey with version = sha256 $ show remaining
            [claim] = fmap (.claim) remaining
            producedInstrument = if isZero' remaining then None else Some newKey
          forA_ producedInstrument $
            tryCreateNewInstrument lifecycler claim electionTime instrumentT
          let (otherConsumed, otherProduced) = Claim.splitPending pending
          effectCid <- toInterfaceContractId <$>
            create ElectionEffect with
              --providers = fromList [instrumentT.issuer, instrumentT.depository]
              providers = fromList [provider, customer]
              custodian = if electorIsOwner then counterparty else elector
              owner = if electorIsOwner then elector else counterparty
              id = id
              description = description
              targetInstrument = currentKey
              producedInstrument
              amount = amount
              otherConsumed
              otherProduced
              settlementTime = Some electionTime
              observers = dv.observers
          --pure (producedInstrument, [effectCid])
          pure [effectCid]
        

    -- nonconsuming choice DeclareAntiDividend : [ContractId Effect.I]
    --   with
    --     privateEquity : InstrumentKey
    --     newVersion : Text
    --     id : Id
    --     description : Text
    --     effectiveTime : Time
    --     amount: Numeric 10
    --   controller customer
    --   do
    --     now <- getTime
    --     (_, peRef) <- fetchByKey @Instrument.R privateEquity 
    --     peInstrument <- fetch (coerceContractId peRef.cid: ContractId PrivateEquity.T)

    --     let
    --       disclosure = toInterface @Disclosure.I peInstrument
    --       dv = view disclosure
    --       newInstrument = InstrumentKey with depository = provider; issuer = customer; id = privateEquity.id; version = newVersion
    --       newLiabilityInstrument = InstrumentKey with depository = provider; issuer = customer; id = privateEquity.id; version = "0"
    --       antiDividend = Quantity 
    --         with 
    --           unit = peInstrument.callInstrument 
    --           amount 

    --     exerciseByKey @Structuring.Service (operator, provider, customer) Structuring.RequestAndCreatePrivateEquity 
    --       with 
    --         id = privateEquity.id
    --         description = peInstrument.description
    --         version = newVersion
    --         validAsOf = now
    --         observers = dv.observers
    --         callInstrument = peInstrument.callInstrument
    --         called = peInstrument.called + amount

    --     eventCid <- exercise (coerceContractId peRef.cid : ContractId Equity.I) Equity.DeclareDividend with id; description; effectiveTime; newInstrument; perUnitDistribution=[antiDividend]
    --     snd <$> exercise distributionRuleCid Lifecycle.Evolve with
    --       eventCid
    --       instrument = privateEquity
    --       observableCids = []

    nonconsuming choice DeclareReplacement : [ContractId Effect.I]
      with
        equity : InstrumentKey
        id : Id
        description : Text
        effectiveTime : Time
        perUnitReplacement : [InstrumentQuantity]
      controller customer
      do
        (_, equityRef) <- fetchByKey @Instrument.R equity
        eventCid <- exercise (coerceContractId equityRef.cid : ContractId Equity.I) Equity.DeclareReplacement with id; description; effectiveTime; perUnitReplacement
        snd <$> exercise replacementRuleCid Lifecycle.Evolve with
          eventCid
          instrument = equity
          observableCids = []

    nonconsuming choice DeclareStockSplit : [ContractId Effect.I]
      with
        equity : InstrumentKey
        newVersion : Text
        id : Id
        description : Text
        effectiveTime : Time
        adjustmentFactor : Decimal
      controller customer
      do
        now <- getTime
        (_, equityRef) <- fetchByKey @Instrument.R equity
        equityInstrument <- fetch equityRef.cid
        let
          disclosure = toInterface @Disclosure.I equityInstrument
          v = view equityInstrument
          dv = view disclosure
          newInstrument = InstrumentKey with depository = provider; issuer = customer; id = v.id; version = newVersion
        exerciseByKey @Structuring.Service (operator, provider, customer) Structuring.RequestAndCreateEquity with id = v.id; description = v.description; version = newVersion; validAsOf = now; observers = dv.observers
        eventCid <- exercise (coerceContractId equityRef.cid : ContractId Equity.I) Equity.DeclareStockSplit with id; description; effectiveTime; newInstrument; adjustmentFactor
        snd <$> exercise replacementRuleCid Lifecycle.Evolve with
          eventCid
          instrument = equity
          observableCids = []

    nonconsuming choice PreviewLifecycle : ([TaggedClaim], [Pending])
      with
        today : Time
        observableCids : [ContractId NumericObservable.I]
        instrumentCid : ContractId Claim.Claim
      controller customer
      do
        instrument <- fetch instrumentCid
        claims <- exercise self GetCurrentClaims with instrumentCid; observableCids
        Claim.lifecycleClaims observableCids ((view instrument).acquisitionTime) claims [Claim.timeEvent today]

    nonconsuming choice SimulateLifecycle : [[Lifecycle.Pending Time InstrumentKey]]
      with
        today : Time
        prices : [Decimal]
        instrumentCid : ContractId Claim.Claim
      controller customer
      do
        instrument <- fetch instrumentCid
        taggedClaims <- Claim.getClaims instrument $ Claim.GetClaims with actor = customer
        let
          claim = mconcat $ map (.claim) taggedClaims
          simulate price = do
            result <- Lifecycle.lifecycle (\_ t -> pure price) claim today today
            pure result.pending
        mapA simulate prices

    nonconsuming choice GetCurrentClaims : [TaggedClaim]
      with
        instrumentCid : ContractId Claim.Claim
        observableCids : [ContractId NumericObservable.I]
      controller customer
      do
        hasClaims <- fetch instrumentCid
        instrument <- fetch (coerceContractId instrumentCid : ContractId Instrument.I)
        fst <$> Claim.lifecycle customer observableCids hasClaims [Claim.timeEvent (view instrument).validAsOf]

    nonconsuming choice Lifecycle : (Optional InstrumentKey, [ContractId Effect.I])
      with
        eventCid : ContractId Event.I
        instrument : InstrumentKey
        observableCids : [ContractId NumericObservable.I]
        ruleCid : ContractId Lifecycle.I
      controller customer
      do
        exercise ruleCid Lifecycle.Evolve with eventCid; observableCids; instrument

    nonconsuming choice Expiry : Optional Time
      with
        claims : C
      controller customer
      do
        pure $ expiry claims

    nonconsuming choice Underlying : [InstrumentKey]
      with
        claims : C
      controller customer
        do
          pure $ snd <$> payoffs claims

    nonconsuming choice Payoffs : [(Observation Time Decimal Text, InstrumentKey)]
      with
        claims : C
      controller customer
        do
          pure $ payoffs claims

    nonconsuming choice Fixings : [Time]
      with
        claims : C
      controller customer
        do
          pure $ fixings claims

    nonconsuming choice Multipliers : [Decimal]
      with
        claims : C
      controller customer
        do
          let getConst : (Observation Time Decimal a, b) -> [Decimal]
              getConst (Const x, _) = [x]
              getConst _            = []
          return $ concatMap getConst $ payoffs claims

    nonconsuming choice PreviewPricing : (Expr Text, Text)
      with
        ccy : Text
        claims : Claim Text Decimal Text Text
      controller customer
      do
        let formula = Pricing.valueClaim ccy claims
        pure (formula, Pricing.print formula)

    choice Terminate : ()
      with
        actor : Party
      controller actor
      do
        assert $ actor == operator || actor == provider || actor == customer
        pure ()

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    distributionRuleCid : ContractId Lifecycle.I
    replacementRuleCid : ContractId Lifecycle.I
    genericRuleCid : ContractId Lifecycle.I
    dynamicRuleCid : ContractId Lifecycle.I
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with ..

    choice Decline : ()
      controller customer
      do pure ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        distributionRuleCid : ContractId Lifecycle.I
        replacementRuleCid : ContractId Lifecycle.I
        genericRuleCid : ContractId Lifecycle.I
        dynamicRuleCid : ContractId Lifecycle.I
      controller operator, provider
      do
        create Service with ..

tryCreateNewInstrument : Party -> C -> Time -> Instrument -> InstrumentKey -> Update ()
tryCreateNewInstrument actor newClaim eventTime oldInstrument newKey = do
  existingRefCidOpt <- lookupByKey @BaseInstrument.R newKey
  case existingRefCidOpt of
    Some existingRefCid -> pure ()
    None -> do
      instCid <- create oldInstrument with
        claims = newClaim
        lastEventTimestamp = eventTime
        version = newKey.version
      BaseInstrument.createReference actor $ toInterfaceContractId instCid
      pure ()