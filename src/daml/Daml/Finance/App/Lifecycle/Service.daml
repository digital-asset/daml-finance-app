-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Lifecycle.Service where

import ContingentClaims.Core.Observation (Observation(..))
import ContingentClaims.Lifecycle.Lifecycle qualified as Lifecycle
import ContingentClaims.Lifecycle.Util qualified as Util (expiry, fixings, payoffs)
import Daml.Finance.App.Interface.Base.Service qualified as Base (I, View(..))
import Daml.Finance.App.Interface.Lifecycle.Service qualified as Service
import Daml.Finance.App.Interface.Structuring.Service qualified as Structuring (CreateEquity(..), I, RequestCreateEquity(..))
import Daml.Finance.App.Lifecycle.Pricing qualified as Pricing
import Daml.Finance.App.Structuring.Service qualified as Structuring (T)
import Daml.Finance.Claims.Util.Lifecycle qualified as Claim (lifecycle, lifecycleClaims, timeEvent)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (I, R, exerciseInterfaceByKey)
import Daml.Finance.Interface.Instrument.Equity.Instrument qualified as Equity (I, DeclareDividend(..), DeclareReplacement(..), DeclareStockSplit(..))
import Daml.Finance.Interface.Claims.Claim qualified as Claim (getClaims, GetClaims(..))
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I, Evolve(..))
import Daml.Finance.Interface.Util.Common (fetchInterfaceByKey)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I)

type T = Service

instance Service.HasImplementation Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    distributionRuleCid : ContractId Lifecycle.I
    replacementRuleCid : ContractId Lifecycle.I
    genericRuleCid : ContractId Lifecycle.I
    dynamicRuleCid : ContractId Lifecycle.I
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    interface instance Base.I for Service where
      view = Base.View with operator; provider; customer

      terminate = pure ()

    interface instance Service.I for Service where
      view = Service.View with distributionRuleCid; replacementRuleCid; genericRuleCid; dynamicRuleCid

      asBase = toInterface @Base.I this

      declareDividend Service.DeclareDividend{equity; newVersion; eventId; description; effectiveTime; perUnitDistribution} = do
        now <- getTime
        instrument <- fetchInterfaceByKey @Instrument.R @Instrument.I equity
        let
          iv = view instrument
          disclosure = view $ toInterface @Disclosure.I instrument
        serviceCid <- toInterfaceContractId @Structuring.I . fst <$> fetchByKey @Structuring.T (operator, provider, customer)
        createEquityRequestCid <- exercise serviceCid Structuring.RequestCreateEquity with id = iv.id; description = iv.description; version = newVersion; validAsOf = now; observers = disclosure.observers
        (_, newInstrument) <- exercise serviceCid Structuring.CreateEquity with createEquityRequestCid
        eventCid <- Instrument.exerciseInterfaceByKey @Equity.I equity customer Equity.DeclareDividend with id = eventId; description; effectiveTime; newInstrument; perUnitDistribution
        effectCids <- snd <$> exercise distributionRuleCid Lifecycle.Evolve with eventCid; instrument = equity; observableCids = []
        pure (newInstrument, effectCids)

      declareReplacement Service.DeclareReplacement{equity; eventId; description; effectiveTime; perUnitReplacement} = do
        eventCid <- Instrument.exerciseInterfaceByKey @Equity.I equity customer Equity.DeclareReplacement with id = eventId; description; effectiveTime; perUnitReplacement
        effectCids <- snd <$> exercise replacementRuleCid Lifecycle.Evolve with eventCid; instrument = equity; observableCids = []
        pure effectCids

      declareStockSplit Service.DeclareStockSplit{equity; newVersion; eventId; description; effectiveTime; adjustmentFactor} = do
        now <- getTime
        instrument <- fetchInterfaceByKey @Instrument.R @Instrument.I equity
        let
          iv = view instrument
          disclosure = view $ toInterface @Disclosure.I instrument
        serviceCid <- toInterfaceContractId @Structuring.I . fst <$> fetchByKey @Structuring.T (operator, provider, customer)
        createEquityRequestCid <- exercise serviceCid Structuring.RequestCreateEquity with id = iv.id; description = iv.description; version = newVersion; validAsOf = now; observers = disclosure.observers
        (_, newInstrument) <- exercise serviceCid Structuring.CreateEquity with createEquityRequestCid
        eventCid <- Instrument.exerciseInterfaceByKey @Equity.I equity customer Equity.DeclareStockSplit with id = eventId; description; effectiveTime; newInstrument; adjustmentFactor
        effectCids <- snd <$> exercise replacementRuleCid Lifecycle.Evolve with eventCid; instrument = equity; observableCids = []
        pure (newInstrument, effectCids)

      previewLifecycle Service.PreviewLifecycle{today; observableCids; instrumentCid} = do
        hasClaims <- fetch instrumentCid
        instrument <- fetch (coerceContractId instrumentCid : ContractId Instrument.I)
        claims <- fst <$> Claim.lifecycle customer observableCids hasClaims [Claim.timeEvent (view instrument).validAsOf]
        Claim.lifecycleClaims observableCids ((view hasClaims).acquisitionTime) claims [Claim.timeEvent today]

      simulateLifecycle Service.SimulateLifecycle{today; prices; instrumentCid} = do
        instrument <- fetch instrumentCid
        taggedClaims <- Claim.getClaims instrument $ Claim.GetClaims with actor = customer
        let
          claim = mconcat $ map (.claim) taggedClaims
          simulate price = do
            result <- Lifecycle.lifecycle (\_ t -> pure price) claim today today
            pure result.pending
        mapA simulate prices

      getCurrentClaims Service.GetCurrentClaims{instrumentCid; observableCids} = do
        hasClaims <- fetch instrumentCid
        instrument <- fetch (coerceContractId instrumentCid : ContractId Instrument.I)
        fst <$> Claim.lifecycle customer observableCids hasClaims [Claim.timeEvent (view instrument).validAsOf]

      lifecycle Service.Lifecycle{ruleCid; eventCid; observableCids; instrument} = do
        exercise ruleCid Lifecycle.Evolve with eventCid; observableCids; instrument

      expiry Service.Expiry{claims} = do
        pure $ Util.expiry claims

      underlyings Service.Underlyings{claims} = do
        pure $ snd <$> Util.payoffs claims

      payoffs Service.Payoffs{claims} = do
        pure $ Util.payoffs claims

      fixings Service.Fixings{claims} = do
        pure $ Util.fixings claims

      multipliers Service.Multipliers{claims} = do
          let getConst : (Observation Time Decimal a, b) -> [Decimal]
              getConst (Const x, _) = [x]
              getConst _            = []
          return $ concatMap getConst $ Util.payoffs claims

      previewPricing Service.PreviewPricing{ccy; claims} = do
        let formula = Pricing.valueClaim ccy claims
        pure (formula, Pricing.print formula)

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    distributionRuleCid : ContractId Lifecycle.I
    replacementRuleCid : ContractId Lifecycle.I
    genericRuleCid : ContractId Lifecycle.I
    dynamicRuleCid : ContractId Lifecycle.I
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with ..

    choice Decline : ()
      controller customer
      do pure ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        distributionRuleCid : ContractId Lifecycle.I
        replacementRuleCid : ContractId Lifecycle.I
        genericRuleCid : ContractId Lifecycle.I
        dynamicRuleCid : ContractId Lifecycle.I
      controller operator, provider
      do
        create Service with ..
