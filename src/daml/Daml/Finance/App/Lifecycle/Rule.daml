-- Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Lifecycle.Rule where

import DA.List (foldl1, groupOn, sortOn)
import DA.Set (member)
import Daml.Finance.Interface.Account.Account qualified as Account (Credit(..), Debit(..), I, exerciseInterfaceByKey)
import Daml.Finance.Interface.Account.Util (getAccount, getCustodian, getOwner)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Util (getAmount)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (Calculate(..), CalculationResult(..), I)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimResult(..))
import Daml.Finance.Interface.Settlement.Factory qualified as Settlement (F, Instruct(..))
import Daml.Finance.Interface.Settlement.RouteProvider qualified as RouteProvider (Discover(..), I)
import Daml.Finance.Interface.Settlement.Types (Step(..))
import Daml.Finance.Interface.Types.Common.Types (Id, Parties)
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Lifecycle.Rule.Util

-- | Type synonym for `Rule`.
type T = Claim

-- | Rule contract that allows an actor to claim effects, returning settlement instructions.
template Claim
  with
    providers : Parties
      -- ^ Providers of the claim rule. Together with the actors of the `ClaimEffect` choice the
      --   authorization requirements to upgrade the holdings being claimed have to be met.
    claimers : Parties
      -- ^ Any of the parties can claim an effect.
    settlers : Parties
      -- ^ Any of the parties can trigger settlement of the resulting batch.
    routeProviderCid : ContractId RouteProvider.I
      -- ^ RouteProvider used to discover settlement routes.
    settlementFactoryCid : ContractId Settlement.F
      -- ^ Settlement factory contract used to create a `Batch` of `Instruction`\s.
    netInstructions : Bool
      -- ^ Configure whether netting should be enabled for quantities having the same (instrument,
      --   sender, receiver).
  where
    signatory providers
    observer claimers

    nonconsuming choice ClaimEffects : Claim.ClaimResult
      -- ^ Claim effects and generate corresponding netted settlement instructions.
      with
        claimer : Party
          -- ^ The party claiming the effect.
        holdingCids : [ContractId Holding.I]
          -- ^ The holdings to process.
        effectCids : [ContractId Effect.I]
          -- ^ The effect to process.
        batchId : Id
          -- ^ Identifier used for the generated settlement batch.
      controller claimer
      do
        assertMsg "Effect can only be claimed by authorized parties." $
          claimer `member` this.claimers

        -- Calculate settlement steps
        let
          createSteps consume quantities holding =
            let
              owner = getOwner holding
              custodian = getCustodian holding
              sender = if consume then owner else custodian
              receiver = if consume then custodian else owner
            in map (\quantity -> Step with sender; receiver; quantity) quantities

          calculateSteps effectCid holdingCid = do
            holding <- fetch holdingCid
            effectView <- view <$> fetch effectCid
            Effect.CalculationResult{consumed; produced} <-
              exercise effectCid Effect.Calculate with actor = claimer; holdingCid
            let
              account = getAccount holding
              amount = getAmount holding
              (consumedNetted, producedNetted) =
                if netInstructions
                then splitPending . net $ mergeConsumedAndProduced consumed produced
                else (consumed, produced)
              consumedSteps = createSteps True consumedNetted holding
              producedSteps = createSteps False producedNetted holding
            -- Debit old instrument
            Account.exerciseInterfaceByKey @Account.I account claimer Account.Debit with holdingCid
            -- Credit new instrument
            case effectView.producedInstrument of
              Some pi -> Some <$> Account.exerciseInterfaceByKey @Account.I account claimer Account.Credit with quantity = qty amount pi
              None -> pure None

            pure $ consumedSteps <> producedSteps

          netSteps : [Step] -> Step
          netSteps steps =
            let
              f s1 s2 =
                if s1.sender == s2.sender && s1.receiver == s2.receiver
                then s1 with quantity.amount = s1.quantity.amount + s2.quantity.amount
                else s1 with quantity.amount = s1.quantity.amount - s2.quantity.amount
              step = foldl1 f steps
            in if step.quantity.amount < 0.0 then step with sender = step.receiver; receiver = step.sender; quantity.amount = -(step.quantity.amount) else step

        -- Settlement steps
        unnettedSteps <- mconcat <$> sequence (zipWith calculateSteps effectCids holdingCids)
        let
          groupedSteps = sortAndGroupOn (\s -> s.quantity.unit) unnettedSteps
          nettedSteps = map netSteps groupedSteps

        -- Discover settlement routes
        routedSteps <- exercise routeProviderCid RouteProvider.Discover with
          discoverors = providers; contextId = None; steps = nettedSteps

        -- Generate settlement instructions for other instruments
        (batchCid, instructionCids) <- exercise settlementFactoryCid Settlement.Instruct with
          instructors = providers
          settlers
          id = batchId
          description = ""
          contextId = Some batchId
          routedSteps
          settlementTime = None

        pure Claim.ClaimResult with batchCid; instructionCids

-- | Like `List.groupOn`, but sorts the list first.
sortAndGroupOn : Ord k => (a -> k) -> [a] -> [[a]]
sortAndGroupOn f l =
  groupOn f $ sortOn f l
