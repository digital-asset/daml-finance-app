module Daml.Finance.App.LettersOfCredit.Service where

import Daml.Finance.App.LettersOfCredit.Model (LoCRequest(..), LoCOffer(..), LoC(..))
import Daml.Finance.App.Structuring.Auto.Service qualified as StructuringAuto (Service, RequestAndCreateGeneric(..))
import Daml.Finance.App.Custody.Service qualified as Custody (Service, RequestDeposit(..), Deposit(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (I)
-- import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I, Acquire(..), I, LockType(..), Release(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, InstrumentQuantity, Id(..), InstrumentKey(..), PartiesMap)
import Daml.Finance.App.Util (fetchAndArchive)
import ContingentClaims.Core.Claim (Claim, and, anytime, at, cond, give, one, or, scale, until, when, zero, (<=))
import DA.Time (time)
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Interface.Instrument.Base.Instrument (getKey)
import Daml.Finance.App.Lifecycle.Service qualified as Lifecycle (Service, AddObserver(..))
import Daml.Finance.Interface.Account.Account qualified as Account (R)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I)
import DA.Set (fromList, singleton)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Split(..), SplitResult(..))

t : Date -> Time
t d = time d 0 0 0

template Service 
  with 
    operator: Party
    provider: Party 
    customer: Party 
    structuringAutoServiceCid: ContractId StructuringAuto.Service 
    custodyServiceCid: ContractId Custody.Service
  where 
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice RequestLoC: ContractId LoCRequest 
      with 
        id: Text 
        beneficiary: Party 
        maturity: Date 
        requested: InstrumentQuantity 
      controller customer 
      do 
        create LoCRequest with ..

    nonconsuming choice OfferLoC: (ContractId LoCOffer ,ContractId Fungible.I)
      with 
        loCRequestCid: ContractId LoCRequest
        granted: InstrumentQuantity 
        acquisitionTime: Time
        lastEventTimestamp : Time
        observers : PartiesMap
        terms: Text
        cashCid : ContractId Fungible.I
        secAccountKey : AccountKey --AR
        cashAccountKey : AccountKey --AR
      controller provider 
      do 
        LoCRequest{operator; provider; customer; maturity; id; beneficiary; requested} <- fetchAndArchive loCRequestCid 
        cashFungibleVisibleToBeneficiary : ContractId Fungible.I <- coerceContractId <$> exercise (coerceContractId cashCid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton provider; observersToAdd = (id, singleton beneficiary)
        cashCidVisibleToBeneficiary <- coerceContractId <$> exercise (coerceContractId cashFungibleVisibleToBeneficiary : ContractId Holding.I) Holding.Acquire with newLockers = singleton customer; context = id; lockType = Holding.Semaphore
        
        exerciseByKey @Lifecycle.Service (operator, provider, provider) Lifecycle.AddObserver with
          newObserver = beneficiary 
        instrumentCid <- exercise structuringAutoServiceCid StructuringAuto.RequestAndCreateGeneric 
          with 
            description = "SBLC "<>id<>" "<> show maturity
            claims = when (at $ t maturity) $ one granted.unit 
            acquisitionTime 
            lastEventTimestamp 
            observers
            ..
        instrument <- fetch instrumentCid
                
        -- Disclose delivering cash account
        
        (_, secAccRef) <- fetchByKey @Account.R secAccountKey
        (_, cashAccRef) <- fetchByKey @Account.R cashAccountKey
        
        exercise (coerceContractId secAccRef.cid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton provider; observersToAdd = (id, singleton beneficiary)
        exercise (coerceContractId cashAccRef.cid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton provider; observersToAdd = (id, singleton beneficiary)

        locOffer <- create LoCOffer 
          with
            tokens = qty (granted.amount) (getKey instrument)
            ..
        return(locOffer,cashCidVisibleToBeneficiary)

    nonconsuming choice AcceptLoC: (ContractId LoC, ContractId Holding.I )
      with 
        loCOfferCid: ContractId LoCOffer 
        account: AccountKey
      controller customer 
      do 
        LoCOffer{operator; provider; customer; maturity; id; beneficiary; requested; granted; terms; tokens} <- fetchAndArchive loCOfferCid
        depositRequestCid <- exercise custodyServiceCid Custody.RequestDeposit
          with 
            quantity = tokens 
            account 
        holdingCid <- exercise custodyServiceCid Custody.Deposit with ..
        locCid <- create LoC with sblc = tokens.unit;..
        return (locCid, holdingCid)

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    structuringAutoServiceCid: ContractId StructuringAuto.Service 
    custodyServiceCid: ContractId Custody.Service
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with operator; provider; customer; structuringAutoServiceCid; custodyServiceCid

    choice Decline : ()
      controller customer
      do
        return ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        structuringAutoServiceCid: ContractId StructuringAuto.Service 
        custodyServiceCid: ContractId Custody.Service
      controller operator, provider
      do
        create Service with operator; provider; customer; structuringAutoServiceCid; custodyServiceCid
