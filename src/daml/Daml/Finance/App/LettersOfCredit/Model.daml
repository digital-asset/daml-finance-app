module Daml.Finance.App.LettersOfCredit.Model where

import Daml.Finance.Interface.Types.Common.Types (AccountKey, InstrumentQuantity,InstrumentKey(..),Id(..))
import Daml.Finance.App.Lifecycle.Service qualified as Lifecycle (Service, Lifecycle(..))
import Daml.Finance.Interface.Lifecycle.Event qualified as Event (I)
import Daml.Finance.Interface.Lifecycle.Observable.NumericObservable qualified as NumericObservable (I)
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (I)
import Daml.Finance.Interface.Lifecycle.Effect qualified as Effect (I)
-- import Daml.Finance.Interface.Types.Common.Types (Id, InstrumentKey(..), InstrumentQuantity)
import Daml.Finance.Interface.Lifecycle.Rule.Claim qualified as Claim (ClaimEffect(..), ClaimResult(..))
import DA.Optional (fromSome)
import DA.List.Total ((!!), head)
import Daml.Finance.App.Custody.Service qualified as Custody ( Service)
-- import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Base qualified as Holding (Acquire(..), I, LockType(..), Release(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (I, Allocate(..), Approve(..))
import DA.Set (singleton)
import DA.List qualified as List (singleton)
import Daml.Finance.Interface.Settlement.Types (Allocation(Pledge), Approval(TakeDelivery), Step(..))
import DA.Foldable (forA_)
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Split(..), SplitResult(..))
import Daml.Finance.Interface.Holding.Util (getAmount)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, AddObservers(..), RemoveObservers(..))

template LoCRequest 
  with 
    operator: Party 
    provider: Party
    customer: Party 
    id: Text
    beneficiary: Party 
    maturity: Date 
    requested: InstrumentQuantity 
  where 
    signatory operator, provider, customer 

    key (operator, provider, id) : (Party, Party, Text)
    maintainer key._1

template LoCOffer
  with 
    operator: Party 
    provider: Party
    customer: Party 
    id: Text
    beneficiary: Party 
    maturity: Date 
    requested: InstrumentQuantity
    granted: InstrumentQuantity
    tokens: InstrumentQuantity
    terms: Text
    -- cashCidVisibleToBeneficiary : ContractId Fungible.I
  where 
    signatory operator, provider, customer 

    key (operator, provider, id) : (Party, Party, Text)
    maintainer key._1

template LoC 
  with 
    operator: Party 
    provider: Party
    customer: Party 
    id: Text
    beneficiary: Party 
    maturity: Date 
    requested: InstrumentQuantity
    granted: InstrumentQuantity
    sblc : InstrumentKey
    terms: Text
    -- cashCidVisibleToBeneficiary : ContractId Fungible.I
  where 
    signatory operator, provider, customer
    observer beneficiary 

    key (operator, provider, id) : (Party, Party, Text)
    maintainer key._1

    nonconsuming choice LifecycleLoc : [ContractId Effect.I]
      with
        eventCid : ContractId Event.I
       
        custodySvcCid : ContractId Custody.Service
        holdingCids : [ContractId Holding.I]
        cashCid : ContractId Holding.I
        cashRecAccount : AccountKey
        secRecAccount : AccountKey
      controller beneficiary
      do
        (_,svc) <- fetchByKey @Lifecycle.Service (operator, provider, provider)
        (_,effects) <- exerciseByKey @Lifecycle.Service (operator, provider, provider) Lifecycle.Lifecycle with 
          instrument = sblc
          ruleCid = svc.genericRuleCid 
          observableCids = []
          ..

        cs <- fetch custodySvcCid
        let effect = fromSome $ head effects

        Claim.ClaimResult{batchCid; instructionCids} <- exercise cs.claimRuleCid Claim.ClaimEffect with claimer = beneficiary; effectCid =  effect; holdingCids; batchId = Id id
        
        cashHolding <-  fetch cashCid
        secHolding <- fetch $ fromSome $ head holdingCids

        let secFungiblCid: ContractId Fungible.I = coerceContractId $ fromSome $ head holdingCids
        let totalSecQuantity = getAmount secHolding
        
        let cashAmount = getAmount cashHolding

        cashHoldingUnlockedCid <- coerceContractId <$> exercise cashCid Holding.Release with context = id
        let cashFungibleCid : ContractId Fungible.I = coerceContractId cashHoldingUnlockedCid

        
        cashCidFungiblePayable  <- 
          if cashAmount > totalSecQuantity
          then do
            Fungible.SplitResult{splitCids, rest} <- exercise cashFungibleCid Fungible.Split with amounts = [ totalSecQuantity ]
            exercise (toInterfaceContractId @Disclosure.I (fromSome rest)) Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (show id, singleton beneficiary)
            pure $  (head splitCids)
          else pure $ Some $ cashFungibleCid
      
        let cashCidPayable:ContractId Holding.I = coerceContractId $ fromSome cashCidFungiblePayable
     
        let 
          doAllocationApproval (iCid : ContractId Instruction.I)  = do
            i <- view <$> fetch iCid
            let 
              sender = i.routedStep.sender
              receiver = i.routedStep.receiver
              holdingCid = fromSome $ head holdingCids
            (iCidNew,_) <- if sender == provider then
              exercise  iCid Instruction.Allocate with actors =  singleton sender;  allocation = Pledge $ toInterfaceContractId $ cashCidPayable
              else
                exercise  iCid Instruction.Allocate with actors =  singleton sender;  allocation = Pledge $ toInterfaceContractId holdingCid
            if receiver == provider then
              exercise iCidNew Instruction.Approve with actors = singleton receiver; approval =  TakeDelivery secRecAccount
              else
                exercise iCidNew Instruction.Approve with actors = singleton receiver; approval = TakeDelivery cashRecAccount
            pure()
            
      
        forA_ instructionCids (\instructionCid -> doAllocationApproval instructionCid)
        exercise  batchCid Batch.Settle with actors = singleton provider
        return effects

        -- return()
