-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Trading.Model where

import DA.Set (fromList, singleton)
import Daml.Finance.App.Interface.Common.Removable qualified as Removable (I, View(..))
import Daml.Finance.App.Interface.Settlement.Service qualified as SettlementService (DiscoverAndInstruct(..))
import Daml.Finance.App.Interface.Trading.CancelOrderRequest qualified as CancelOrderRequest (HasImplementation, I, View(..))
import Daml.Finance.App.Interface.Trading.CreateOrderRequest qualified as CreateOrderRequest (HasImplementation, I, View(..))
import Daml.Finance.App.Interface.Trading.Order qualified as Order (ApproveInstruction(..), Fill(..), FillResult(..), HasImplementation, I, Side(..), View(..))
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Split(..), SplitResult(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Allocate(..), Approve(..))
import Daml.Finance.Interface.Settlement.Types (Allocation(Pledge), Approval(TakeDelivery), Step(..))
import Daml.Finance.Interface.Types.Common.Types (AccountKey, Id(..), InstrumentQuantity, Parties)
import Daml.Finance.Interface.Util.Common (qty)

instance Order.HasImplementation Order

template Order
  with
    operator : Party
    provider : Party
    customer : Party
    id : Id
    timestamp : Time
    listingId : Id
    quantity : InstrumentQuantity
    side : Order.Side
    price : InstrumentQuantity
    collateralCid : ContractId Fungible.I
    account : AccountKey
    observers : Parties
  where
    signatory operator, provider, customer
    observer observers

    key (operator, provider, id) : (Party, Party, Id)
    maintainer key._1

    interface instance Removable.I for Order where
      view = Removable.View with removers = fromList [operator, provider, customer]

    interface instance Order.I for Order where
      view = Order.View with
        operator
        provider
        customer
        id
        timestamp
        listingId
        quantity
        side
        price
        collateralCid
        account
        observers

      asRemovable = toInterface @Removable.I this

      fill Order.Fill{settlementServiceCid; other; isResting} = do
        let
          paid = if isResting then price.amount else other.price.amount
          delivered = min quantity.amount other.quantity.amount
          amount = if side == Order.Buy then paid * delivered else delivered
          remaining = quantity.amount - min quantity.amount other.quantity.amount
          deliverable = if side == Order.Buy then price.unit else quantity.unit
          step = Step with sender = customer; receiver = other.customer; quantity = qty amount deliverable
          actors = fromList [provider, customer] -- provider has to be part of Allocate actors due to holding being locked to them
        (batchCid, [instructionCid]) <- exercise settlementServiceCid SettlementService.DiscoverAndInstruct with
          actor = provider
          settlers = singleton provider
          id
          description = show id
          contextId = Some id
          settlementTime = None
          steps = [step]
        Fungible.SplitResult [splitCid] restCidOpt <- exercise collateralCid Fungible.Split with amounts = [ amount ]
        if remaining == 0.0
        then do
          instructionCid <- fst <$> exercise instructionCid Instruction.Allocate with actors; allocation = Pledge $ toInterfaceContractId splitCid
          pure Order.FillResult with orderOpt = None; batchCid; instructionCid
        else do
          instructionCid <- fst <$> exercise instructionCid Instruction.Allocate with actors; allocation = Pledge $ toInterfaceContractId splitCid
          case restCidOpt of
            Some restCid -> do
              let new = this with quantity.amount = remaining; collateralCid = restCid
              newCid <- toInterfaceContractId <$> create new
              pure Order.FillResult with orderOpt = Some (newCid, view $ toInterface @Order.I new); batchCid; instructionCid
            None -> fail "Insufficient collateral - this should never happen"

      approveInstruction Order.ApproveInstruction{instructionCid} = do
        exercise instructionCid Instruction.Approve with actors = singleton customer; approval = TakeDelivery account

instance CreateOrderRequest.HasImplementation CreateOrderRequest

template CreateOrderRequest
  with
    operator : Party
    provider : Party
    customer : Party
    id : Id
    timestamp : Time
    listingId : Id
    quantity : InstrumentQuantity
    side : Order.Side
    price : InstrumentQuantity
    collateralCid : ContractId Fungible.I
    account : AccountKey
    orderCids : [ContractId Order.I]
    observers : Parties
  where
    signatory operator, provider, customer

    key (operator, provider, id) : (Party, Party, Id)
    maintainer key._1

    interface instance Removable.I for CreateOrderRequest where
      view = Removable.View with removers = fromList [operator, provider, customer]

    interface instance CreateOrderRequest.I for CreateOrderRequest where
      view = CreateOrderRequest.View with
        operator
        provider
        customer
        id
        timestamp
        listingId
        quantity
        side
        price
        collateralCid
        account
        orderCids
        observers

      asRemovable = toInterface @Removable.I this

instance CancelOrderRequest.HasImplementation CancelOrderRequest

template CancelOrderRequest
  with
    provider : Party
    customer : Party
    operator : Party
    orderCid : ContractId Order.I
  where
    signatory provider, customer

    interface instance Removable.I for CancelOrderRequest where
      view = Removable.View with removers = fromList [operator, provider, customer]

    interface instance CancelOrderRequest.I for CancelOrderRequest where
      view = CancelOrderRequest.View with
        operator
        provider
        customer
        orderCid

      asRemovable = toInterface @Removable.I this
