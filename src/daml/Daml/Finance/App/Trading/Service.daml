-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Trading.Service where

import DA.Action (foldlA, when)
import DA.Optional (isNone)
import DA.Set (insert, singleton)
import Daml.Finance.App.Interface.Common.Util (fetchAndRemove)
import Daml.Finance.App.Interface.Base.Service qualified as Base (I, View(..))
import Daml.Finance.App.Interface.Settlement.Service qualified as SettlementService (I)
import Daml.Finance.App.Interface.Trading.CancelOrderRequest qualified as CancelOrderRequest (View(..))
import Daml.Finance.App.Interface.Trading.CreateOrderRequest qualified as CreateOrderRequest (View(..))
import Daml.Finance.App.Interface.Trading.Order qualified as Order (ApproveInstruction(..), Fill(..), FillResult(..), I, Side(..), View(..))
import Daml.Finance.App.Interface.Trading.Service qualified as Service (CancelOrder(..), CreateOrder(..), ExecuteOrder(..), HasImplementation, I, RequestCancelOrder(..), RequestCreateOrder(..), View(..))
import Daml.Finance.App.Settlement.Service qualified as SettlementService (T)
import Daml.Finance.App.Trading.Model qualified as Model (CancelOrderRequest(..), CreateOrderRequest(..), Order(..))
import Daml.Finance.Interface.Account.Account qualified as Account (exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Holding.Base qualified as Holding (Acquire(..), I, LockType(..), Release(..))
import Daml.Finance.Interface.Account.Util (getAccount)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, AddObservers(..), RemoveObservers(..))
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Approve(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Types (Approval(TakeDelivery))

type T = Service

instance Service.HasImplementation Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    interface instance Base.I for Service where
      view = Base.View with operator; provider; customer
      terminate = pure ()

    interface instance Service.I for Service where
      view = Service.View

      asBase = toInterface @Base.I this

      requestCreateOrder Service.RequestCreateOrder{id; listingId; quantity; price; side; collateralCid; account; orderCids; observers} = do
        timestamp <- getTime
        collateral <- fetch collateralCid
        disclosedCollateralCid <- coerceContractId <$> exercise (coerceContractId collateralCid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (show id, provider `insert` observers)
        Account.exerciseInterfaceByKey @Disclosure.I (getAccount collateral) customer Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (show id, provider `insert` observers)
        Account.exerciseInterfaceByKey @Disclosure.I account customer Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (show id, provider `insert` observers)
        toInterfaceContractId <$> create Model.CreateOrderRequest with operator; provider; customer; id; timestamp; listingId; quantity; price; side; collateralCid = disclosedCollateralCid; account; orderCids; observers

      requestCancelOrder Service.RequestCancelOrder{orderCid} = do
        toInterfaceContractId <$> create Model.CancelOrderRequest with operator; provider; customer; orderCid

      createOrder self Service.CreateOrder{createOrderRequestCid} = do
        CreateOrderRequest.View{operator; provider; customer; id; timestamp; listingId; quantity; price; side; collateralCid; account; orderCids; observers} <- view <$> fetchAndRemove createOrderRequestCid
        lockedCollateralCid : ContractId Fungible.I <- coerceContractId <$> exercise (toInterfaceContractId collateralCid : ContractId Holding.I) Holding.Acquire with newLockers = singleton provider; context = show id; lockType = Holding.Semaphore
        orderCid <- toInterfaceContractId <$> create Model.Order with operator; provider; customer; id; timestamp; listingId; quantity; price; side; collateralCid = lockedCollateralCid; account; observers
        exercise self Service.ExecuteOrder with orderCid; orderCids

      cancelOrder Service.CancelOrder{cancelOrderRequestCid} = do
        CancelOrderRequest.View{orderCid} <- view <$> fetchAndRemove cancelOrderRequestCid
        order <- view <$> fetchAndRemove orderCid
        exercise (toInterfaceContractId order.collateralCid : ContractId Holding.I) Holding.Release with context = show order.id
        pure ()

      executeOrder Service.ExecuteOrder{orderCid; orderCids} = do
        order <- view <$> fetch orderCid
        orderViews <- zip orderCids <$> mapA (fmap view . fetch) orderCids
        settlementServiceCid <- toInterfaceContractId @SettlementService.I . fst <$> fetchByKey @SettlementService.T (operator, provider, customer)
        let
          orders = filter (\(_, o) -> o.customer /= customer && if order.side == Order.Buy then o.side == Order.Sell && o.price.amount <= order.price.amount else o.side == Order.Buy && o.price.amount >= order.price.amount) orderViews
          match : Optional (ContractId Order.I, Order.View) -> (ContractId Order.I, Order.View) -> Update (Optional (ContractId Order.I, Order.View))
          match myOpt (otherCid, other) =
            case myOpt of
              None -> do
                pure None
              Some (myCid, my) | my.side == Order.Buy && my.price.amount < other.price.amount || my.side == Order.Sell && my.price.amount > other.price.amount -> do
                pure myOpt
              Some (myCid, my) -> do
                myCollateral <- fetch my.collateralCid
                otherCollateral <- fetch other.collateralCid
                Order.FillResult{orderOpt; batchCid; instructionCid} <- exercise myCid Order.Fill with settlementServiceCid; other; isResting = False
                exercise otherCid Order.ApproveInstruction with instructionCid
                [transferableCid] <- exercise batchCid Batch.Settle with actors = singleton provider
                exercise (toInterfaceContractId transferableCid : ContractId Holding.I) Holding.Release with context = show my.id
                Order.FillResult{orderOpt = otherOpt; batchCid; instructionCid} <- exercise otherCid Order.Fill with settlementServiceCid; other = my; isResting = True
                exercise instructionCid Instruction.Approve with actors = singleton provider; approval = TakeDelivery my.account
                [transferableCid] <- exercise batchCid Batch.Settle with actors = singleton provider
                exercise (toInterfaceContractId transferableCid : ContractId Holding.I) Holding.Release with context = show other.id
                when (isNone orderOpt) do
                  Account.exerciseInterfaceByKey @Disclosure.I my.account provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (show my.id, singleton provider)
                  Account.exerciseInterfaceByKey @Disclosure.I (getAccount myCollateral) provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (show my.id, singleton provider)
                  pure ()
                when (isNone otherOpt) do
                  Account.exerciseInterfaceByKey @Disclosure.I other.account provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (show other.id, singleton provider)
                  Account.exerciseInterfaceByKey @Disclosure.I (getAccount otherCollateral) provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (show other.id, singleton provider)
                  pure ()
                pure orderOpt
        foldlA match (Some (orderCid, order)) orders

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with operator; provider; customer

    choice Decline : ()
      controller customer
      do
        return ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
      controller operator, provider
      do
        create Service with operator; provider; customer
