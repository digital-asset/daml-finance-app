-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Trading.Service where

import DA.Action (foldlA, when)
import DA.Optional (isNone)
import DA.Set (insert, singleton)
import Daml.Finance.App.Trading.Model (ApproveInstruction(..), CreateOrderRequest(..), CancelOrderRequest(..), Fill(..), FillResult(..), Order(..), Side(..))
import Daml.Finance.App.Util (fetchAndArchive)
import Daml.Finance.Interface.Holding.Account qualified as Account (K, exerciseInterfaceByKey)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (Q)
import Daml.Finance.Interface.Holding.Lockable qualified as Lockable (Acquire(..), I, LockType(..), Release(..))
import Daml.Finance.Interface.Holding.Util (getAccount)
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (I, AddObservers(..), RemoveObservers(..))
import Daml.Finance.Interface.Settlement.Factory qualified as Factory (I)
import Daml.Finance.Interface.Settlement.Instruction qualified as Instruction (Approve(..))
import Daml.Finance.Interface.Settlement.Batch qualified as Batch (Settle(..))
import Daml.Finance.Interface.Settlement.Types (Approval(TakeDelivery))
import Daml.Finance.Interface.Types.Common (Id, Parties)

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    settlementFactoryCid : ContractId Factory.I
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    nonconsuming choice RequestCreateOrder : ContractId CreateOrderRequest
      with
        id : Id
        listingId : Text
        quantity : Instrument.Q
        price : Instrument.Q
        side : Side
        collateralCid : ContractId Fungible.I
        account : Account.K
        observers : Parties
        orderCids : [ContractId Order]
      controller customer
      do
        timestamp <- getTime
        collateral <- fetch collateralCid
        disclosedCollateralCid <- coerceContractId <$> exercise (coerceContractId collateralCid : ContractId Disclosure.I) Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (show id, provider `insert` observers)
        Account.exerciseInterfaceByKey @Disclosure.I (getAccount collateral) customer Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (show id, provider `insert` observers)
        Account.exerciseInterfaceByKey @Disclosure.I account customer Disclosure.AddObservers with disclosers = singleton customer; observersToAdd = (show id, provider `insert` observers)
        create CreateOrderRequest with operator; provider; customer; id; timestamp; listingId; quantity; price; side; collateralCid = disclosedCollateralCid; account; orderCids; observers

    nonconsuming choice RequestCancelOrder : ContractId CancelOrderRequest
      with
        orderCid : ContractId Order
      controller customer
      do
        create CancelOrderRequest with operator; provider; customer; orderCid

    nonconsuming choice CreateOrder : Optional (ContractId Order, Order)
      with
        createOrderRequestCid : ContractId CreateOrderRequest
      controller provider
      do
        CreateOrderRequest{operator; provider; customer; id; timestamp; listingId; quantity; price; side; collateralCid; account; orderCids; observers} <- fetchAndArchive createOrderRequestCid
        lockedCollateralCid : ContractId Fungible.I <- coerceContractId <$> exercise (coerceContractId collateralCid : ContractId Lockable.I) Lockable.Acquire with newLocker = (singleton provider); context = show id; lockType = Lockable.Semaphore
        orderCid <- create Order with operator; provider; customer; id; timestamp; listingId; quantity; price; side; collateralCid = lockedCollateralCid; account; observers
        exercise self ExecuteOrder with orderCid; orderCids

    nonconsuming choice CancelOrder : ()
      with
        cancelOrderRequestCid : ContractId CancelOrderRequest
      controller provider
      do
        CancelOrderRequest{orderCid} <- fetchAndArchive cancelOrderRequestCid
        order <- fetchAndArchive orderCid
        exercise (coerceContractId order.collateralCid : ContractId Lockable.I) Lockable.Release with context = show order.id
        pure ()

    nonconsuming choice ExecuteOrder : Optional (ContractId Order, Order)
      with
        orderCid : ContractId Order
        orderCids : [ContractId Order]
      controller provider
      do
        order <- fetch orderCid
        -- TODO: Filter out own orders
        orders <- filter (\(_, o) -> if order.side == Buy then o.side == Sell && o.price.amount <= order.price.amount else o.side == Buy && o.price.amount >= order.price.amount) . zip orderCids <$> mapA fetch orderCids
        let
          match : Optional (ContractId Order, Order) -> (ContractId Order, Order) -> Update (Optional (ContractId Order, Order))
          match myOpt (otherCid, other) =
            case myOpt of
              None -> do
                pure None
              Some (myCid, my) | my.side == Buy && my.price.amount < other.price.amount || my.side == Sell && my.price.amount > other.price.amount -> do
                pure myOpt
              Some (myCid, my) -> do
                myCollateral <- fetch my.collateralCid
                otherCollateral <- fetch other.collateralCid
                FillResult{orderOpt; batchCid; instructionCid} <- exercise myCid Fill with settlementFactoryCid; other; isResting = False
                exercise otherCid ApproveInstruction with instructionCid
                [transferableCid] <- exercise batchCid Batch.Settle with actors = singleton provider
                -- exercise (coerceContractId transferableCid : ContractId Lockable.I) Lockable.Release with context = my.id
                FillResult{orderOpt = otherOpt; batchCid; instructionCid} <- exercise otherCid Fill with settlementFactoryCid; other = my; isResting = True
                exercise instructionCid Instruction.Approve with approval = TakeDelivery my.account
                [transferableCid] <- exercise batchCid Batch.Settle with actors = singleton provider
                -- exercise (coerceContractId transferableCid : ContractId Lockable.I) Lockable.Release with context = other.id
                when (isNone orderOpt) do
                  Account.exerciseInterfaceByKey @Disclosure.I my.account provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (show my.id, singleton provider)
                  Account.exerciseInterfaceByKey @Disclosure.I (getAccount myCollateral) provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (show my.id, singleton provider)
                  pure ()
                when (isNone otherOpt) do
                  Account.exerciseInterfaceByKey @Disclosure.I other.account provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (show other.id, singleton provider)
                  Account.exerciseInterfaceByKey @Disclosure.I (getAccount otherCollateral) provider Disclosure.RemoveObservers with disclosers = singleton provider; observersToRemove = (show other.id, singleton provider)
                  pure ()
                pure orderOpt
        foldlA match (Some (orderCid, order)) orders

    choice Terminate : ()
      with
        actor : Party
      controller actor
      do
        assert $ actor == operator || actor == provider || actor == customer
        pure ()

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    settlementFactoryCid : ContractId Factory.I
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with operator; provider; customer; settlementFactoryCid

    choice Decline : ()
      controller customer
      do
        return ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        settlementFactoryCid : ContractId Factory.I
      controller operator, provider
      do
        create Service with operator; provider; customer; settlementFactoryCid
