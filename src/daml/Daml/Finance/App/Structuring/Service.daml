-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.App.Structuring.Service where

import DA.Date (toGregorian)
import Daml.Finance.App.Interface.Base.Service qualified as Base (I, View(..))
import Daml.Finance.App.Interface.Common.Util (fetchAndRemove)
import Daml.Finance.App.Interface.Structuring.CreateTokenRequest qualified as CreateTokenRequest (View(..))
import Daml.Finance.App.Interface.Structuring.CreateEquityRequest qualified as CreateEquityRequest (View(..))
import Daml.Finance.App.Interface.Structuring.CreateGenericRequest qualified as CreateGenericRequest (View(..))
import Daml.Finance.App.Interface.Structuring.CreateFixedRateBondRequest qualified as CreateFixedRateBondRequest (View(..))
import Daml.Finance.App.Interface.Structuring.CreateFloatingRateBondRequest qualified as CreateFloatingRateBondRequest (View(..))
import Daml.Finance.App.Interface.Structuring.CreateInflationLinkedBondRequest qualified as CreateInflationLinkedBondRequest (View(..))
import Daml.Finance.App.Interface.Structuring.CreateZeroCouponBondRequest qualified as CreateZeroCouponBondRequest (View(..))
import Daml.Finance.App.Interface.Structuring.CreateFpmlSwapRequest qualified as CreateFpmlSwapRequest (View(..))
import Daml.Finance.App.Interface.Structuring.Service qualified as Service
import Daml.Finance.App.Structuring.Model
import Daml.Finance.Interface.Instrument.Bond.FixedRate.Factory qualified as FixedRateBond (Factory, Create(..))
import Daml.Finance.Interface.Instrument.Bond.FixedRate.Types (FixedRate(..))
import Daml.Finance.Interface.Instrument.Bond.FloatingRate.Factory qualified as FloatingRateBond (Factory, Create(..))
import Daml.Finance.Interface.Instrument.Bond.FloatingRate.Types (FloatingRate(..))
import Daml.Finance.Interface.Instrument.Bond.InflationLinked.Factory qualified as InflationLinkedBond (Factory, Create(..))
import Daml.Finance.Interface.Instrument.Bond.InflationLinked.Types (InflationLinked(..))
import Daml.Finance.Interface.Instrument.Bond.ZeroCoupon.Factory qualified as ZeroCouponBond (Factory, Create(..))
import Daml.Finance.Interface.Instrument.Bond.ZeroCoupon.Types (ZeroCoupon(..))
import Daml.Finance.Interface.Instrument.Equity.Factory qualified as Equity (Factory, Create(..))
import Daml.Finance.Interface.Instrument.Generic.Factory qualified as Generic (Factory, Create(..))
import Daml.Finance.Interface.Instrument.Swap.Fpml.Factory qualified as FpmlSwap (Factory, Create(..))
import Daml.Finance.Interface.Instrument.Swap.Fpml.Types (Fpml(..))
import Daml.Finance.Interface.Instrument.Token.Factory qualified as Token (Factory, Create(..))
import Daml.Finance.Interface.Instrument.Token.Types (Token(..))
import Daml.Finance.Interface.Types.Common.Types (InstrumentKey(..))
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayAdjustment(..), BusinessDayConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum, RollConventionEnum(..))
import Daml.Finance.Interface.Types.Date.Schedule (Frequency(..), PeriodicSchedule(..))

type T = Service

instance Service.HasImplementation Service

template Service
  with
    operator : Party
    provider : Party
    customer : Party
    token : ContractId Token.Factory
    equity : ContractId Equity.Factory
    generic : ContractId Generic.Factory
    fixedRateBond : ContractId FixedRateBond.Factory
    floatingRateBond : ContractId FloatingRateBond.Factory
    inflationLinkedBond : ContractId InflationLinkedBond.Factory
    zeroCouponBond : ContractId ZeroCouponBond.Factory
    fpmlSwap : ContractId FpmlSwap.Factory
  where
    signatory operator, provider, customer

    key (operator, provider, customer) : (Party, Party, Party)
    maintainer key._1

    interface instance Base.I for Service where
      view = Base.View with operator; provider; customer
      terminate = pure ()

    interface instance Service.I for Service where
      view = Service.View with token; equity; generic; fixedRateBond; floatingRateBond; inflationLinkedBond; zeroCouponBond; fpmlSwap

      asBase = toInterface @Base.I this

      requestCreateToken Service.RequestCreateToken{..} = do
        toInterfaceContractId <$> create CreateTokenRequest with ..

      requestCreateEquity Service.RequestCreateEquity{..} = do
        toInterfaceContractId <$> create CreateEquityRequest with ..

      requestCreateGeneric Service.RequestCreateGeneric{..} = do
        toInterfaceContractId <$> create CreateGenericRequest with ..

      requestCreateFixedRateBond Service.RequestCreateFixedRateBond{..} = do
        toInterfaceContractId <$> create CreateFixedRateBondRequest with ..

      requestCreateFloatingRateBond Service.RequestCreateFloatingRateBond{..} = do
        toInterfaceContractId <$> create CreateFloatingRateBondRequest with ..

      requestCreateInflationLinkedBond Service.RequestCreateInflationLinkedBond{..} = do
        toInterfaceContractId <$> create CreateInflationLinkedBondRequest with ..

      requestCreateZeroCouponBond Service.RequestCreateZeroCouponBond{..} = do
        toInterfaceContractId <$> create CreateZeroCouponBondRequest with ..

      requestCreateFpmlSwap Service.RequestCreateFpmlSwap{..} = do
        toInterfaceContractId <$> create CreateFpmlSwapRequest with ..

      createToken Service.CreateToken{createTokenRequestCid} = do
        CreateTokenRequest.View{..} <- view <$> fetchAndRemove createTokenRequestCid
        let
          instrument = InstrumentKey with depository = provider; issuer = customer; id; version
          tokenData = Token with ..
        cid <- exercise token Token.Create with token = tokenData; observers
        pure (cid, instrument)

      createEquity Service.CreateEquity{createEquityRequestCid} = do
        CreateEquityRequest.View{..} <- view <$> fetchAndRemove createEquityRequestCid
        let
          instrument = InstrumentKey with depository = provider; issuer = customer; id; version
        cid <- exercise equity Equity.Create with ..
        pure (cid, instrument)

      createGeneric Service.CreateGeneric{createGenericRequestCid} = do
        CreateGenericRequest.View{..} <- view <$> fetchAndRemove createGenericRequestCid
        let
          instrument = InstrumentKey with depository = provider; issuer = customer; id; version
        cid <- exercise generic Generic.Create with ..
        pure (cid, instrument)

      createFixedRateBond Service.CreateFixedRateBond{createFixedRateBondRequestCid} = do
        CreateFixedRateBondRequest.View{..} <- view <$> fetchAndRemove createFixedRateBondRequestCid
        let
          instrument = InstrumentKey with depository = provider; issuer = customer; id; version
          periodicSchedule = createCouponPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
          fixedRate = FixedRate with ..
        cid <- exercise fixedRateBond FixedRateBond.Create with fixedRate; observers
        pure (cid, instrument)

      createFloatingRateBond Service.CreateFloatingRateBond{createFloatingRateBondRequestCid} = do
        CreateFloatingRateBondRequest.View{..} <- view <$> fetchAndRemove createFloatingRateBondRequestCid
        let
          instrument = InstrumentKey with depository = provider; issuer = customer; id; version
          periodicSchedule = createCouponPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
          floatingRate = FloatingRate with ..
        cid <- exercise floatingRateBond FloatingRateBond.Create with floatingRate; observers
        pure (cid, instrument)

      createInflationLinkedBond Service.CreateInflationLinkedBond{createInflationLinkedBondRequestCid} = do
        CreateInflationLinkedBondRequest.View{..} <- view <$> fetchAndRemove createInflationLinkedBondRequestCid
        let
          instrument = InstrumentKey with depository = provider; issuer = customer; id; version
          periodicSchedule = createCouponPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
          inflationLinked = InflationLinked with ..
        cid <- exercise inflationLinkedBond InflationLinkedBond.Create with inflationLinked; observers
        pure (cid, instrument)

      createZeroCouponBond Service.CreateZeroCouponBond{createZeroCouponBondRequestCid} = do
        CreateZeroCouponBondRequest.View{..} <- view <$> fetchAndRemove createZeroCouponBondRequestCid
        let
          instrument = InstrumentKey with depository = provider; issuer = customer; id; version
          zeroCoupon = ZeroCoupon with ..
        cid <- exercise zeroCouponBond ZeroCouponBond.Create with zeroCoupon; observers
        pure (cid, instrument)

      createFpmlSwap Service.CreateFpmlSwap{createFpmlSwapRequestCid} = do
        CreateFpmlSwapRequest.View{..} <- view <$> fetchAndRemove createFpmlSwapRequestCid
        let
          instrument = InstrumentKey with depository = provider; issuer = customer; id; version
          fpml = Fpml with ..
        cid <- exercise fpmlSwap FpmlSwap.Create with fpml; observers
        pure (cid, instrument)

template Offer
  with
    operator : Party
    provider : Party
    customer : Party
    token : ContractId Token.Factory
    equity : ContractId Equity.Factory
    generic : ContractId Generic.Factory
    fixedRateBond : ContractId FixedRateBond.Factory
    floatingRateBond : ContractId FloatingRateBond.Factory
    inflationLinkedBond : ContractId InflationLinkedBond.Factory
    zeroCouponBond : ContractId ZeroCouponBond.Factory
    fpmlSwap : ContractId FpmlSwap.Factory
  where
    signatory operator, provider
    observer customer

    choice Accept : ContractId Service
      controller customer
      do
        create Service with ..

    choice Decline : ()
      controller customer
      do pure ()

    choice Withdraw : ()
      controller provider
      do pure ()

template Request
  with
    customer : Party
    provider : Party
  where
    signatory customer
    observer provider

    choice Cancel : ()
      controller customer
      do pure ()

    choice Reject : ()
      controller provider
      do pure ()

    choice Approve : ContractId Service
      with
        operator : Party
        token : ContractId Token.Factory
        equity : ContractId Equity.Factory
        generic : ContractId Generic.Factory
        fixedRateBond : ContractId FixedRateBond.Factory
        floatingRateBond : ContractId FloatingRateBond.Factory
        inflationLinkedBond : ContractId InflationLinkedBond.Factory
        zeroCouponBond : ContractId ZeroCouponBond.Factory
        fpmlSwap : ContractId FpmlSwap.Factory
      controller operator, provider
      do
        create Service with ..

-- | Create a schedule for the periodic coupon payments.
createCouponPeriodicSchedule : Date -> [Text] -> BusinessDayConventionEnum -> PeriodEnum -> Int -> Date -> Date -> PeriodicSchedule
createCouponPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate = do
  let
    (y, m, d) = toGregorian firstCouponDate
    periodicSchedule = PeriodicSchedule with
      businessDayAdjustment =
        BusinessDayAdjustment with
          calendarIds = holidayCalendarIds
          convention = businessDayConvention
      effectiveDateBusinessDayAdjustment = None
      terminationDateBusinessDayAdjustment = None
      frequency =
        Frequency with
          rollConvention = DOM d
          period = couponPeriod
          periodMultiplier = couponPeriodMultiplier
      effectiveDate = issueDate
      firstRegularPeriodStartDate = Some firstCouponDate
      lastRegularPeriodEndDate = Some maturityDate
      stubPeriodType = None
      terminationDate = maturityDate
  periodicSchedule