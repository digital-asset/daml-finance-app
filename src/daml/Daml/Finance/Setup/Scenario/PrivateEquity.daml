module Daml.Finance.Setup.Scenario.PrivateEquity where

import DA.Map (empty, fromList)
import DA.Set (singleton)

import Daml.Script 

import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Settlement.Hierarchy qualified as Settlement (Hierarchy(..))

import Daml.Finance.Setup.Util.Common
import Daml.Finance.Setup.Util.Role
import Daml.Finance.Setup.Util.Service
import Daml.Finance.Setup.Util.Workflow
import Daml.Finance.Setup.Payoff
import DA.Foldable (mapA_)
import DA.Date
import DA.Time (time)
import Daml.Finance.Interface.Util.Common (qty, fetchInterfaceByKey)
import Daml.Finance.Interface.Types.Common.Types (Id(..))
-- import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Split(..))
--import Daml.Finance.Interface.Account.Account qualified as Account

import Daml.Finance.App.Lending.Model qualified as Lending (Repay(..))
import Daml.Finance.App.Lending.Service qualified as Lending (AcceptBorrowOffer(..), CreateBorrowOffer(..), RequestBorrowOffer(..), Service)

{-
Suggested flow for demo of distribution in the UI:
1. Show holdings of fund manager and investors.
2. Fund manager creates new PE Distribution for 1m of PE1, with payment instrument PE1-COMMITMENT.
3. Investors1, 2, 3 bid for 0.5m, 0.2m, 0.3m respectively.
4. Transfer agent closes the auction.
5. Look at Custody to see that the holdings are correct.

Suggested flow for demo of lending in the UI:
1. Complete demo of distribution shown above.
2. Fund manager creates a new borrow request for 0.4m USD, with any maturity date in the future.
3. Bank goes to requests, sees the borrow request and creates an offer with interest instrument = USD, interest amount = 1000 USD, collateral instrument PE1-COMMITMENT, collateral amount 0.44m.
4. Fund manager accepts the borrow offer.
5. Look at Custody to see that the holdings are correct.
6. Fund manager repays the loan.
7. Look at Custody to see that the holdings are correct.
-}

run: Script [PartyInfo]
run = do
  let scenario = "Private Equity"
  parties <- allocateParties scenario ["Operator", "FundManager", "Admin", "TransferAgent", "WealthManager", "Investor1", "Investor2", "Investor3", "Bank"] "Public"
   -- bank is the lender for the loan part of the demo
  let 
    all@[operator, issuer, admin, ta, wm, inv1, inv2, inv3, bank, public] = map (.id) parties 
    pub = fromList [("Public", singleton public)]
    investorNames = [
      ("Investor1", inv1),
      ("Investor2", inv2),
      ("Investor3", inv3)]

  -- Factories
  let 
    assetLabels = ["PE1", "PE2", "PE3", "TSLA"]
    settlementPaths = [[issuer], [inv1], [inv2], [inv3], [bank]]

    cashRoute = Settlement.Hierarchy -- In lending TSLA will share this route also
      with 
        rootCustodian = ta
        -- pathsToRootCustodian = List.delete [ta] settlementPaths
        pathsToRootCustodian = settlementPaths
    --cashPath = [("USD", cashRoute)]

    secRoute = Settlement.Hierarchy 
      with 
        rootCustodian = issuer 
        pathsToRootCustodian = settlementPaths
        --pathsToRootCustodian = List.delete [issuer] settlementPaths
    secPath = map (\a -> (a, secRoute)) assetLabels

    commitments = map (<>"-COMMITMENT") assetLabels
  
    -- Each investor has its own settlement route for commitment tokens, with just the issuer (and bank) as a sub-custodian
    commitmentPaths = map (\(rootCustodian, i) -> (i, Settlement.Hierarchy with pathsToRootCustodian = [[issuer], [bank]]; .. )) [
      (inv1, "PE1-COMMITMENT"),
      (inv2, "PE1-COMMITMENT"),
      (inv3, "PE1-COMMITMENT")]

    [commitmentPath1, commitmentPath2, commitmentPath3] = commitmentPaths
    
  accountFactoryCid<- toInterfaceContractId 
    <$> submit operator do createCmd Account.Factory  with provider = operator; observers = pub 
  holdingFactoryCid <- toInterfaceContractId
    <$> submit operator do createCmd Fungible.Factory with provider = operator; observers = pub 

  -- Roles 
  createOperatorRole operator
  createDistributorRole operator ta
  let 
    custodianRoles = [inv1, inv2, inv3, ta, admin, issuer, bank] 
  mapA_ (createCustodianRole operator) custodianRoles
  -- createDistributorRole   operator admin 

  -- Services 
  -- Custody Services
  let 
    cashPath = [("USD", cashRoute)]
    secPath = map (\a -> (a, secRoute)) assetLabels
    custodyServices = [
      (inv1, issuer, commitmentPath1 :: cashPath), 
      (inv2, issuer, commitmentPath2 :: cashPath), 
      (inv3, issuer, commitmentPath3 :: cashPath),
      (inv1, inv1, [commitmentPath1]), 
      (inv2, inv2, [commitmentPath2]), 
      (inv3, inv3, [commitmentPath3]),
      (ta, issuer, cashPath), 
      (ta, inv1, cashPath),
      (ta, inv2, cashPath), 
      (ta, inv3, cashPath),
      -- (admin, inv1, []),
      -- (admin, inv2, []),
      -- (admin, inv3, []),
      (admin, issuer, []), -- dummy to make ui work, remove if possible
      (issuer, issuer, secPath),
      (issuer, inv1, secPath),
      (issuer, inv2, secPath),
      (issuer, inv3, secPath),
      -- Lending below
      (ta, bank, cashPath), -- for bank cash and TSLA. To work with existing lending service the bank and borrower account for TSLA have to have the same custodian
      (inv1, bank, [commitmentPath1]),
      (inv2, bank, [commitmentPath2]),
      (inv3, bank, [commitmentPath3])
      ]

  mapA_ (\(provider, customer, p) -> createCustodyService 
    operator provider customer (fromList p) accountFactoryCid holdingFactoryCid) custodyServices
  
  --issuance services
  let 
    issuanceServices = [
      (inv1, inv1),
      (inv2, inv2), 
      (inv3, inv3), 
      (issuer, issuer)]

  mapA_ (\(provider, customer) -> do 
    createIssuanceService operator provider customer 
    createIssuanceAutoService operator provider customer) issuanceServices

  --lifecycle services
  let 
    lifecycleServices = [
      (inv1, admin), 
      (inv2, admin), 
      (inv3, admin),
      (inv1, issuer), 
      (inv2, issuer), 
      (inv3, issuer)]

  mapA_ (\(provider, customer) -> createLifecycleService operator provider customer public) lifecycleServices
  
  -- Structuring service 
  createStructuringService operator admin issuer 
  createStructuringAutoService operator admin issuer

  createPEDistributionService operator ta issuer secPath
  createPEDistributionAutoService operator ta issuer

  createPEBiddingService          operator ta       inv1
  createPEBiddingAutoService      operator ta       inv1
  createPEBiddingService          operator ta       inv2
  createPEBiddingAutoService      operator ta       inv2
  createPEBiddingService          operator ta       inv3
  createPEBiddingAutoService      operator ta       inv3
  -- Time 
  t <- getTime 
  let 
    today = toDateUTC t 
    todayTime = time today 0 0 0
    tt d = time d 0 0 0 
    epoch = tt $ date 1970 Jan 1
    (ty, tm, td) = toGregorian today 
  (clockCid, eventCid) <- createClockAndEvent all today $ singleton public

  -- Instruments 
  usd       <- originateToken ta ta pub epoch "USD" "United States Dollar"
  usdCommit1 <- originateGeneric admin issuer pub epoch "PE1-COMMITMENT" "USD Commitment to PE1" $ capitalCommitment usd epoch
  pe1        <- originateEquity issuer issuer pub epoch "PE1" "Private Equity Fund 1 Shares" 
 -- pe2        <- originateEquity issuer issuer pub epoch "PE2" "Private Equity Fund 2 Shares"
 -- pe3        <- originateEquity issuer issuer pub epoch "PE3" "Private Equity Fund 3 Shares"
 -- usdCommit2 <- originateGeneric admin issuer pub epoch "PE2-COMMITMENT" "USD Commitment to PE2" $ capitalCommitment usd epoch
 -- usdCommit3 <- originateGeneric admin issuer pub epoch "PE3-COMMITMENT" "USD Commitment to PE3" $ capitalCommitment usd epoch
  let usdCommit = usdCommit1

  -- Accounts
  let 
    createAccount' provider customer name obs = createAccount operator provider customer public name obs

    adminObs = fromList [("Admin", singleton admin), ("FundManager", singleton issuer)]

  -- Commit Accounts
  issuerCommitAccount1      <- createAccount'  inv1 issuer "FundManager@Inv1|Commitments" adminObs
  issuerCommitAccount2      <- createAccount'  inv2 issuer "FundManager@Inv2|Commitments" adminObs
  issuerCommitAccount3      <- createAccount'  inv3 issuer "FundManager@Inv3|Commitments" adminObs
  -- 'Dummy' account to enable creation of an auction in the UI but not used to hold commitments
  issuerCommitAccountD      <- createAccount'  admin issuer "FundManager@Admin|Commitments" adminObs

  inv1UncommittedAccount <- createAccount'  inv1 inv1   "Investor1|Uncommitted" empty 
  inv2UncommittedAccount <- createAccount'  inv2 inv2   "Investor2|Uncommitted" empty 
  inv3UncommittedAccount <- createAccount'  inv3 inv3   "Investor3|Uncommitted" empty 

  -- Cash Accounts 
  issuerCashAccount         <- createAccount' ta issuer "FundManager@TA|Cash" empty 
  inv1CashAccount           <- createAccount' ta inv1   "Investor1@TA|Cash" empty 
  inv2CashAccount           <- createAccount' ta inv2   "Investor2@TA|Cash" empty
  inv3CashAccount           <- createAccount' ta inv3   "Investor3@TA|Cash" empty

  -- Security Accounts 
  issuerSecAccount          <- createAccount' issuer issuer "FundManager@FundManager|Securities" empty 
  inv1SecAccount            <- createAccount' issuer inv1   "Investor1@FundManager|Securities" empty 
  inv2SecAccount            <- createAccount' issuer inv2   "Investor2@FundManager|Securities" empty
  inv3SecAccount            <- createAccount' issuer inv3   "Investor3@FundManager|Securities" empty

  -- Directories 
  createAccountDirectory issuer [(usd, issuerCashAccount)]    $ singleton public 
  createAccountDirectory inv1 [(usd, inv1CashAccount), (usdCommit1, issuerCommitAccount1)]        $singleton ta
  createAccountDirectory inv2 [(usd, inv2CashAccount), (usdCommit1, issuerCommitAccount2)]        $singleton ta
  createAccountDirectory inv3 [(usd, inv3CashAccount), (usdCommit1, issuerCommitAccount3)]        $singleton ta
  
  -- -- Holdings 
  -- issuerCommit1Cid <- deposit operator inv1 issuer public (qty 25_000_000.00 usdCommit) issuerCommitAccount1
  -- issuerCommit2Cid <- deposit operator inv2 issuer public (qty 35_000_000.00 usdCommit) issuerCommitAccount2
  -- issuerCommit3Cid <- deposit operator inv3 issuer public (qty 40_000_000.00 usdCommit) issuerCommitAccount3

  inv1CashCid      <- deposit operator ta inv1 public (qty 200_000_000.00 usd) inv1CashAccount
  inv2CashCid      <- deposit operator ta inv2 public (qty 200_000_000.00 usd) inv2CashAccount
  inv3CashCid      <- deposit operator ta inv3 public (qty 200_000_000.00 usd) inv3CashAccount

  inv1UncommitedCid   <- deposit operator inv1 inv1 public (qty 60_000_000.00 usdCommit) inv1UncommittedAccount
  inv2UncommitedCid   <- deposit operator inv2 inv2 public (qty 70_000_000.00 usdCommit) inv2UncommittedAccount
  inv3UncommitedCid   <- deposit operator inv3 inv3 public (qty 90_000_000.00 usdCommit) inv3UncommittedAccount

  -- inv1Shares1Cid    <- deposit operator issuer inv1 public (qty 25_000_000.00 pe1) inv1SecAccount
  -- inv2Shares1Cid    <- deposit operator issuer inv2 public (qty 35_000_000.00 pe1) inv2SecAccount
  -- inv3Shares1Cid    <- deposit operator issuer inv3 public (qty 40_000_000.00 pe1) inv3SecAccount
  -- issuerShares1Cid  <- deposit operator issuer issuer public (qty 1_000_000.00 pe1) issuerSecAccount

  -- Issuances (Test)
  (_, ad1) <- issue operator issuer issuer public (qty 1_000_000.0 pe1)   issuerSecAccount
  -- (_, invCommitHolding1) <- issue operator inv1 inv1 public (qty 50_000_000.00 usdCommit) $ inv1UncommittedAccount
  -- (_, issuerPe2Holding) <- issue operator ta issuer public (qty 80_000_000.00 pe2) $ issuerSecAccount

  -- Capital Call (Test)

  -- declareCapitalCall : Party -> Party -> Party -> Party -> InstrumentKey -> InstrumentKey -> Time -> Numeric 10 -> Script (ContractId Effect.I)
  -- declareCapitalCall operator provider issuer public commitment ccy effectiveTime amount
-- LEVE'S TEST START
  -- capitalCallEffectId <- declareCapitalCall operator inv1 issuer public usdCommit usd t 5_000_000.0
  -- claimCapitalCallEffect operator inv1 issuer public capitalCallEffectId 5_000_000.00 (coerceContractId issuerCommit1Cid: ContractId Fungible.I) $ Id "Round 1"

  -- COMMENTED LEVE'S CODE BELOW
  -- capitalCallEffectId <- declareCapitalCall operator inv1 issuer public usdCommit usd t 5_000_000.0
  -- claimCapitalCallEffect operator inv1 issuer public capitalCallEffectId 5_000_000.00 (coerceContractId issuerCommit1Cid: ContractId Fungible.I) $ Id "Round 1"

  -- capitalCallEffectId <- declareCapitalCall operator inv2 issuer public usdCommit usd t 7_000_000.0
  -- claimCapitalCallEffect operator inv2 issuer public capitalCallEffectId 7_000_000.00 (coerceContractId issuerCommit2Cid: ContractId Fungible.I) $ Id "Round 1"

  -- capitalCallEffectId <- declareCapitalCall operator inv3 issuer public usdCommit usd t 8_000_000.0
  -- claimCapitalCallEffect operator inv3 issuer public capitalCallEffectId 8_000_000.00 (coerceContractId issuerCommit3Cid: ContractId Fungible.I) $ Id "Round 1"
  -- END LEVE'S COMMENTED CODE


  -- Need to do a split and expose first
  --(batchCid, instructionCids) <- claimEffect operator inv1 admin public capitalCallEffectId [issuerCommit1Cid] $ Id "Round 1"


  -- PE DISTRIBUTION TEST
  let
    doPEDistribution = do
      -- PE Distribution (Test)
      let quantity = qty 1_000_000.0 pe1
      -- When creating the distribution, need to pass in all the issuer commitment accounts so that they can be disclosed to the Transfer Agent.
      -- In implementation, investors could be invited to bid so that their accounts are identified.
      distributionCid        <- createPEDistribution operator ta issuer public "DISTRIBUTION1" quantity usdCommit 1.0 (coerceContractId ad1) [issuerCommitAccount1, issuerCommitAccount2, issuerCommitAccount3]
      inv1CollateralCid <- coerceContractId <$> getHolding inv1 (qty 500_000.0 usdCommit)
      inv2CollateralCid <- coerceContractId <$> getHolding inv2 (qty 300_000.0 usdCommit)
      inv3CollateralCid <- coerceContractId <$> getHolding inv3 (qty 200_000.0 usdCommit)
    
      inv1BidCid        <- createPEDistributionBid operator ta inv1 public distributionCid 500_000.0 1.0 inv1CollateralCid inv1SecAccount
      inv2BidCid        <- createPEDistributionBid operator ta inv2 public distributionCid 300_000.0 1.0 inv2CollateralCid inv2SecAccount
      inv3BidCid        <- createPEDistributionBid operator ta inv3 public distributionCid 200_000.0 1.0 inv3CollateralCid inv3SecAccount
      processPEDistribution operator ta issuer public distributionCid [inv1BidCid, inv2BidCid, inv3BidCid]

  --doPEDistribution


  -- SECURITIES LENDING TEST
  -- Investor1 will borrow 0.4m USD and provide 440,000 PE1-COMMITMENT as collateral

  createLendingService operator bank issuer -- operator lender borrower

  -- bank account
  bankCashAccount <- createAccount' ta bank "Bank@TA|Cash" empty

   -- Credit lender with USD
  borrowedCid   <- coerceContractId <$> deposit operator ta bank public (qty 400_000.0 usd) bankCashAccount
  -- Credit the borrower with cash to pay the interest
  interestCid   <- coerceContractId <$> deposit operator ta issuer public (qty 1_000.0 usd) issuerCashAccount
  -- Loan collateral is the PE1COMM held by the issuer at inv1

  -- Do the loan
  let
    doLoan = do
      let
        borrowedQty   = qty     400_000.0 usd
        interestQty   = qty     1_000.0 usd
        collateralQty = qty 440_000.0 usdCommit1

      collateralCid <- coerceContractId <$> getHolding issuer collateralQty

      borrowOfferRequestCid <- submit issuer do exerciseByKeyCmd @Lending.Service (operator, bank, issuer) Lending.RequestBorrowOffer with id = "BORROW"; borrowed = borrowedQty; maturity = date 2022 Sep 14
      borrowOfferCid <- submit bank do exerciseByKeyCmd @Lending.Service (operator, bank, issuer) Lending.CreateBorrowOffer with borrowOfferRequestCid; interest = interestQty; collateral = collateralQty; borrowedCid; lenderBorrowedAccount = bankCashAccount; lenderInterestAccount = bankCashAccount
      (borrowedCid, borrowAgreementCid) <- submitMulti [issuer] [public] do exerciseByKeyCmd @Lending.Service (operator, bank, issuer) Lending.AcceptBorrowOffer with borrowOfferCid; collateralCid; account = issuerCashAccount
      submitMulti [issuer] [public] do exerciseCmd borrowAgreementCid Lending.Repay with borrowedCid; interestCid
      pure ()

  -- doLoan

  pure parties