module Daml.Finance.Setup.Scenario.PrivateEquity where

import DA.Map (empty, fromList)
import DA.Set (singleton)

import Daml.Script 

import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Settlement.Hierarchy qualified as Settlement (Hierarchy(..))

import Daml.Finance.Setup.Util.Common
import Daml.Finance.Setup.Util.Role
import Daml.Finance.Setup.Util.Service
import Daml.Finance.Setup.Util.Workflow
import Daml.Finance.Setup.Payoff
import DA.Foldable (mapA_)
import DA.Date
import DA.Time (time)
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Interface.Types.Common.Types (Id(..))
-- import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Split(..))

run: Script [PartyInfo]
run = do 
  let scenario = "Private Equity"
  parties <- allocateParties scenario ["Operator", "FundManager", "Admin", "TransferAgent", "WealthManager", "Investor1", "Investor2", "Investor3"] "Public"
  let 
    all@[operator, issuer, admin, ta, wm, inv1, inv2, inv3, public] = map (.id) parties 
    pub = fromList [("Public", singleton public)]
    investorNames = [
      ("Investor1", inv1),
      ("Investor2", inv2),
      ("Investor3", inv3)]

  -- Factories
  let 
    assetLabels = ["PE1", "PE2", "PE3"]
    settlementPaths = [[issuer], [ta], [admin], [wm], [inv1], [inv2], [inv3]]
    cashRoute = Settlement.Hierarchy 
      with 
        rootCustodian = ta
        pathsToRootCustodian = settlementPaths
    secRoute = Settlement.Hierarchy 
      with 
        rootCustodian = issuer 
        pathsToRootCustodian = settlementPaths
    commitments = map (<>"-COMMITMENT") assetLabels
    commitmentRoute1 = Settlement.Hierarchy 
      with 
        rootCustodian = inv1 
        pathsToRootCustodian = settlementPaths
    commitmentRoute2 = Settlement.Hierarchy 
      with 
        rootCustodian = inv2 
        pathsToRootCustodian = settlementPaths
    commitmentRoute3 = Settlement.Hierarchy 
      with 
        rootCustodian = inv3 
        pathsToRootCustodian = settlementPaths
    
    commitmentPaths = map (\(rootCustodian, i) -> (i, Settlement.Hierarchy with pathsToRootCustodian = settlementPaths; .. )) [
      (inv1, "PE1-COMMITMENT"), 
      (inv2, "PE1-COMMITMENT"), 
      (inv3, "PE1-COMMITMENT")]

    paths = fromList $ [("USD", cashRoute)] ++ commitmentPaths ++ map (\a -> (a, secRoute)) assetLabels

  accountFactoryCid<- toInterfaceContractId 
    <$> submit operator do createCmd Account.Factory  with provider = operator; observers = pub 
  holdingFactoryCid <- toInterfaceContractId
    <$> submit operator do createCmd Fungible.Factory with provider = operator; observers = pub 

  -- Roles 
  createOperatorRole operator
  createDistributorRole operator issuer
  let 
    custodianRoles = [inv1, inv2, inv3, ta, admin, issuer] 
  mapA_ (createCustodianRole operator) custodianRoles
  -- createDistributorRole   operator admin 

  -- Services 
  -- Custody Services
  let 
    custodyServices = [
      (inv1, issuer), 
      (inv2, issuer), 
      (inv3, issuer),
      (inv1, inv1), 
      (inv2, inv2), 
      (inv3, inv3),
      (inv1, admin), 
      (inv2, admin), 
      (inv3, admin),
      (ta, issuer), 
      (ta, inv1),
      (ta, inv2), 
      (ta, inv3),
      (admin, inv1),
      (admin, inv2),
      (admin, inv3),
      (admin, issuer),
      (issuer, issuer),
      (issuer, inv1),
      (issuer, inv2),
      (issuer, inv3)]

  mapA_ (\(provider, customer) -> createCustodyService 
    operator provider customer paths accountFactoryCid holdingFactoryCid) custodyServices
  
  --issuance services
  let 
    issuanceServices = [
      (inv1, inv1),
      (inv2, inv2), 
      (inv3, inv3), 
      (issuer, issuer)]

  mapA_ (\(provider, customer) -> do 
    createIssuanceService operator provider customer 
    createIssuanceAutoService operator provider customer) issuanceServices

  --lifecycle services
  let 
    lifecycleServices = [
      (inv1, admin), 
      (inv2, admin), 
      (inv3, admin),
      (inv1, issuer), 
      (inv2, issuer), 
      (inv3, issuer)]

  mapA_ (\(provider, customer) -> createLifecycleService operator provider customer public) lifecycleServices

  createAuctionAutoService      operator issuer       issuer
  createBiddingService          operator issuer       inv1
  createBiddingAutoService      operator issuer       inv1
  createBiddingService          operator issuer       inv2
  createBiddingAutoService      operator issuer       inv2
  createBiddingService          operator issuer       inv3
  createBiddingAutoService      operator issuer       inv3
  
  -- Structuring service 
  createStructuringService operator admin issuer 
  createStructuringAutoService operator admin issuer 

  -- Time 
  t <- getTime 
  let 
    today = toDateUTC t 
    todayTime = time today 0 0 0
    tt d = time d 0 0 0 
    epoch = tt $ date 1970 Jan 1
    (ty, tm, td) = toGregorian today 
  (clockCid, eventCid) <- createClockAndEvent all today $ singleton public

  -- Instruments 
  usd       <- originateToken ta ta pub epoch "USD" "United States Dollar"
  usdCommit1 <- originateGeneric admin issuer pub epoch "PE1-COMMITMENT" "USD Commitment to PE1" $ capitalCommitment usd epoch
  pe1        <- originateEquity admin issuer pub epoch "PE1" "Private Equity Fund 1 Shares" 
  pe2        <- originateEquity admin issuer pub epoch "PE2" "Private Equity Fund 2 Shares"
  pe3        <- originateEquity admin issuer pub epoch "PE3" "Private Equity Fund 3 Shares"
  usdCommit2 <- originateGeneric admin issuer pub epoch "PE2-COMMITMENT" "USD Commitment to PE2" $ capitalCommitment usd epoch
  usdCommit3 <- originateGeneric admin issuer pub epoch "PE3-COMMITMENT" "USD Commitment to PE3" $ capitalCommitment usd epoch
  let usdCommit = usdCommit1
  -- Accounts
  let 
    createAccount' provider customer name obs = createAccount operator provider customer public name obs
    adminObs = fromList [("Admin", singleton admin), ("FundManager", singleton issuer)]

  -- Commit Accounts
  issuerCommitAccount1      <- createAccount'  inv1 issuer "FundManager@Inv1|Commitments" adminObs
  issuerCommitAccount2      <- createAccount'  inv2 issuer "FundManager@Inv2|Commitments" adminObs
  issuerCommitAccount3      <- createAccount'  inv3 issuer "FundManager@Inv3|Commitments" adminObs

  -- Hardcode three auction settlement accounts into the Auction Service
  createAuctionService          operator issuer       issuer paths issuerCommitAccount1 issuerCommitAccount2 issuerCommitAccount3

  inv1UncommittedAccount <- createAccount'  inv1 inv1   "Investor1|Uncommitted" empty 
  inv2UncommittedAccount <- createAccount'  inv2 inv2   "Investor2|Uncommitted" empty 
  inv3UncommittedAccount <- createAccount'  inv3 inv3   "Investor3|Uncommitted" empty 

  -- Cash Accounts 
  issuerCashAccount         <- createAccount' ta issuer "FundManager@TA|Cash" empty 
  inv1CashAccount           <- createAccount' ta inv1   "Investor1@TA|Cash" empty 
  inv2CashAccount           <- createAccount' ta inv2   "Investor2@TA|Cash" empty
  inv3CashAccount           <- createAccount' ta inv3   "Investor3@TA|Cash" empty

  -- Security Accounts 
  issuerSecAccount          <- createAccount' issuer issuer "FundManager@Admin|Securities" empty 
  inv1SecAccount            <- createAccount' issuer inv1   "Investor1@Admin|Securities" empty 
  inv2SecAccount            <- createAccount' issuer inv2   "Investor2@Admin|Securities" empty
  inv3SecAccount            <- createAccount' issuer inv3   "Investor3@Admin|Securities" empty

  -- Holdings 
  issuerCommit1Cid <- deposit operator inv1 issuer public (qty 25_000_000.00 usdCommit) issuerCommitAccount1
  issuerCommit2Cid <- deposit operator inv2 issuer public (qty 35_000_000.00 usdCommit) issuerCommitAccount2
  issuerCommit3Cid <- deposit operator inv3 issuer public (qty 40_000_000.00 usdCommit) issuerCommitAccount3

  inv1CashCid      <- deposit operator ta inv1 public (qty 200_000_000.00 usd) inv1CashAccount
  inv2CashCid      <- deposit operator ta inv2 public (qty 200_000_000.00 usd) inv2CashAccount
  inv3CashCid      <- deposit operator ta inv3 public (qty 200_000_000.00 usd) inv3CashAccount

  --inv1UncommitedCid   <- deposit operator inv1 inv1 public (qty 60_000_000.00 usdCommit) inv1UncommittedAccount
  inv2UncommitedCid   <- deposit operator inv2 inv2 public (qty 70_000_000.00 usdCommit) inv2UncommittedAccount
  inv3UncommitedCid   <- deposit operator inv3 inv3 public (qty 90_000_000.00 usdCommit) inv3UncommittedAccount

  inv1Shares1Cid    <- deposit operator issuer inv1 public (qty 25_000_000.00 pe1) inv1SecAccount
  inv2Shares1Cid    <- deposit operator issuer inv2 public (qty 35_000_000.00 pe1) inv2SecAccount
  inv3Shares1Cid    <- deposit operator issuer inv3 public (qty 40_000_000.00 pe1) inv3SecAccount
  issuerShares1Cid  <- deposit operator issuer issuer public (qty 1_000_00.00 pe1) issuerSecAccount

  -- Issuances (Test)
  (_, ad1) <- issue operator issuer issuer public (qty 1_000_000.0 pe1)   issuerSecAccount
  -- (_, invCommitHolding1) <- issue operator inv1 inv1 public (qty 50_000_000.00 usdCommit) $ inv1UncommittedAccount
  -- (_, issuerPe2Holding) <- issue operator ta issuer public (qty 80_000_000.00 pe2) $ issuerSecAccount

  -- Capital Call (Test)

  -- declareCapitalCall : Party -> Party -> Party -> Party -> InstrumentKey -> InstrumentKey -> Time -> Numeric 10 -> Script (ContractId Effect.I)
  -- declareCapitalCall operator provider issuer public commitment ccy effectiveTime amount

  capitalCallEffectId <- declareCapitalCall operator inv1 issuer public usdCommit usd t 5_000_000.0
  claimCapitalCallEffect operator inv1 issuer public capitalCallEffectId 5_000_000.00 (coerceContractId issuerCommit1Cid: ContractId Fungible.I) $ Id "Round 1"

  -- Need to do a split and expose first
  --(batchCid, instructionCids) <- claimEffect operator inv1 admin public capitalCallEffectId [issuerCommit1Cid] $ Id "Round 1"

  -- Auction (Test)
  -- let
  --   doAuction = do
  -- let quantity = qty 1_000_000.0 pe1
  -- auctionCid        <- createAuction operator issuer issuer public "AUCTION1" quantity usdCommit 0.95 (coerceContractId ad1) issuerCashAccount
  -- inv1CollateralCid <- coerceContractId <$> getHolding inv1 (qty 500_010.0 usdCommit)
  -- inv2CollateralCid <- coerceContractId <$> getHolding inv2 (qty 392_000.0 usdCommit)
  -- inv3CollateralCid <- coerceContractId <$> getHolding inv3 (qty 297_000.0 usdCommit)
  -- inv1BidCid        <- createAuctionBid operator issuer inv1 public auctionCid 500_010.0 1.0  inv1CollateralCid inv1SecAccount
  -- inv2BidCid        <- createAuctionBid operator issuer inv2 public auctionCid 392_000.0 1.0 inv2CollateralCid inv2SecAccount
  -- inv3BidCid        <- createAuctionBid operator issuer inv3 public auctionCid 297_000.0 1.0 inv3CollateralCid inv3SecAccount
  --processAuction operator issuer issuer public auctionCid [inv1BidCid, inv2BidCid, inv3BidCid]

  -- doAuction
  pure parties
{-
fst <$> exercise instructionCid Instruction.Allocate with actors = singleton customer; allocation = T.Pledge $ toInterfaceContractId transferableCid

  Bid {
    operator = 'Operator-Private Equity', 
    provider = 'FundManager-Private Equity', 
    customer = 'Investor1-Private Equity', 
    issuer = 'FundManager-Private Equity', 
    details = Details {
      quantity = Quantity {
        unit = InstrumentKey {
          depository = 'Admin-Private Equity', 
          issuer = 'FundManager-Private Equity', 
          id = PE1, 
          version = "0"
        }, 
        amount = 500010.0
      }, 
      price = Quantity {
        unit = InstrumentKey {
          depository = 'Admin-Private Equity', 
          issuer = 'FundManager-Private Equity', 
          id = PE1-COMMITMENT, 
          version = "0"
        }, 
        amount = 1.0
      }, 
      time = 1970-01-01T00:00:00Z
    }, 
    auctionId = "AUCTION1", 
    collateralCid = <contract-id>, 
    receivableAccount = AccountKey {
      custodian = 'FundManager-Private Equity', 
      owner = 'Investor1-Private Equity', 
      id = Investor1@Admin|Securities
    }, 
    status = FullAllocation {price = 1.0}
  }
-}