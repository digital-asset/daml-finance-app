module Daml.Finance.Setup.Scenario.PrivateEquity where

import DA.Map (empty, fromList)
import DA.Set (singleton)

import Daml.Script 

import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Settlement.Hierarchy qualified as Settlement (Hierarchy(..))

import Daml.Finance.Setup.Util.Common
import Daml.Finance.Setup.Util.Role
import Daml.Finance.Setup.Util.Service
import Daml.Finance.Setup.Util.Workflow
import Daml.Finance.Setup.Payoff
import DA.Foldable (mapA_)
import DA.Date
import DA.Time (time)
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I)

import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)

run: Script [PartyInfo]
run = do 
  let scenario = "Private Equity"
  parties <- allocateParties scenario ["Operator", "Issuer", "Admin", "TransferAgent", "WealthManager", "Investor1", "Investor2", "Investor3"] "Public"
  let 
    all@[operator, issuer, admin, ta, wm, inv1, inv2, inv3, public] = map (.id) parties 
    pub = fromList [("Public", singleton public)]
    investorNames = [
      ("Investor1", inv1),
      ("Investor2", inv2),
      ("Investor3", inv3)]

  -- Factories
  let 
    assetLabels = ["PE1", "PE2", "PE3"]
    settlementPaths = [[issuer], [ta], [admin], [wm], [inv1], [inv2], [inv3]]
    cashRoute = Settlement.Hierarchy 
      with 
        rootCustodian = ta
        pathsToRootCustodian = settlementPaths 
    secRoute = Settlement.Hierarchy 
      with 
        rootCustodian = ta 
        pathsToRootCustodian = settlementPaths 
    paths = fromList $ ("USD", cashRoute) :: map (\a -> (a, secRoute)) assetLabels
  accountFactoryCid<- toInterfaceContractId 
    <$> submit operator do createCmd Account.Factory  with provider = operator; observers = pub 
  holdingFactoryCid <- toInterfaceContractId
    <$> submit operator do createCmd Fungible.Factory with provider = operator; observers = pub 

  -- Roles 
  createOperatorRole operator
  createDistributorRole operator ta
  let 
    custodianRoles = [inv1, inv2, inv3, ta, admin] 
  mapA_ (createCustodianRole operator) custodianRoles
  -- createDistributorRole   operator admin 

  -- Services 
  -- Custody Services
  let 
    custodyServices = [
      (inv1, issuer), 
      (inv2, issuer), 
      (inv3, issuer),
      (inv1, inv1), 
      (inv2, inv2), 
      (inv3, inv3),
      (inv1, admin), 
      (inv2, admin), 
      (inv3, admin),
      (ta, issuer), 
      (ta, inv1),
      (ta, inv2), 
      (ta, inv3)]

  mapA_ (\(provider, customer) -> createCustodyService 
    operator provider customer paths accountFactoryCid holdingFactoryCid) custodyServices
  
  --issuance services
  let 
    issuanceServices = [
      (inv1, inv1),
      (inv2, inv2), 
      (inv3, inv3), 
      (ta, issuer)]

  mapA_ (\(provider, customer) -> do 
    createIssuanceService operator provider customer 
    createIssuanceAutoService operator provider customer) issuanceServices

  let 
    lifecycleServices = [
      (inv1, admin), 
      (inv2, admin), 
      (inv3, admin),
      (inv1, issuer), 
      (inv2, issuer), 
      (inv3, issuer)]

  mapA_ (\(provider, customer) -> createLifecycleService operator provider customer public) lifecycleServices

  createAuctionService          operator ta       issuer paths
  createAuctionAutoService      operator ta       issuer
  createBiddingService          operator ta       inv1
  createBiddingAutoService      operator ta       inv1
  createBiddingService          operator ta       inv2
  createBiddingAutoService      operator ta       inv2
  createBiddingService          operator ta       inv3
  createBiddingAutoService      operator ta       inv3

  -- Admin is going to Structure Equities and Capital Commitments.
  -- createStructuringService      operator ta admin 
  -- createStructuringAutoService  operator ta admin

  -- -- Issuer will issue PE Tokens. 
  -- -- createIssuanceService         operator admin issuer 
  -- -- createIssuanceAutoService     operator admin issuer         

  -- -- WMs will issue Capital commitments 
  -- -- createIssuanceService         operator admin wm
  -- -- createIssuanceAutoService     operator admin wm 

  -- -- Investors will issuer their own capital commitments 
  -- mapA_ (\(_, inv) -> do 
  --   createIssuanceService         operator admin inv 
  --   createStructuringAutoService  operator admin inv) (investorNames)

  -- createLifecycleService        operator ta issuer public 
  -- createLifecycleService        operator admin issuer public 

  -- --mapA_ (\(_, inv) -> createLifecycleService operator admin inv public) investorNames

  -- mapA_ (\(provider, customer) -> createSettlementService 
  --   operator provider customer paths ) custodyServices
  
  -- Time 
  t <- getTime 
  let 
    today = toDateUTC t 
    todayTime = time today 0 0 0
    tt d = time d 0 0 0 
    epoch = tt $ date 1970 Jan 1
    (ty, tm, td) = toGregorian today 
  (clockCid, eventCid) <- createClockAndEvent all today $ singleton public

  -- Instruments 
  usd       <- originateToken ta ta pub epoch "USD" "United States Dollar"
  usdCommit <- originateGeneric ta admin pub epoch "PE1-COMMITMENT" "USD Commitment to PE1" $ capitalCommitment usd epoch
  pe1        <- originateEquity admin issuer pub epoch "PE1" "Private Equity Fund 1 Shares" 
  pe2        <- originateEquity admin issuer pub epoch "PE2" "Private Equity Fund 2 Shares"
  pe3        <- originateEquity admin issuer pub epoch "PE3" "Private Equity Fund 3 Shares"
  
  -- Accounts
  let 
    createAccount' provider customer name obs = createAccount operator provider customer public name obs
    adminObs = fromList [("Admin", singleton admin), ("Issuer", singleton issuer)]

  -- Commit Accounts
  issuerCommitAccount1      <- createAccount'  inv1 issuer "Issuer@Inv1|Commitments" adminObs 
  issuerCommitAccount2      <- createAccount'  inv2 issuer "Issuer@Inv2|Commitments" adminObs
  issuerCommitAccount3      <- createAccount'  inv3 issuer "Issuer@Inv3|Commitments" adminObs

  inv1UncommittedAccount <- createAccount'  inv1 inv1   "Investor1|Uncommitted" empty 
  inv2UncommittedAccount <- createAccount'  inv2 inv2   "Investor2|Uncommitted" empty 
  inv3UncommittedAccount <- createAccount'  inv3 inv3   "Investor3|Uncommitted" empty 

  -- Cash Accounts 
  issuerCashAccount         <- createAccount' ta issuer "Issuer@TA|Cash" empty 
  inv1CashAccount           <- createAccount' ta inv1   "Investor1@TA|Cash" empty 
  inv2CashAccount           <- createAccount' ta inv2   "Investor2@TA|Cash" empty
  inv3CashAccount           <- createAccount' ta inv3   "Investor3@TA|Cash" empty

  -- Security Accounts 
  issuerSecAccount          <- createAccount' ta issuer "Issuer@TA|Securities" empty 
  inv1SecAccount            <- createAccount' ta inv1   "Investor1@TA|Securities" empty 
  inv2SecAccount            <- createAccount' ta inv2   "Investor2@TA|Securities" empty
  inv3SecAccount            <- createAccount' ta inv3   "Investor3@TA|Securities" empty

  -- Holdings 
  issuerCommit1Cid <- deposit operator inv1 issuer public (qty 25_000_000.00 usdCommit) issuerCommitAccount1
  --issuerCommit1Cid <- submit issuer $ coerceInterfaceContractId <$> exerciseCmd (toInterfaceContractId @Disclosure.I issuerCommit1Cid) Disclosure.AddObservers with disclosers = singleton issuer; observersToAdd = ("Admin", singleton admin)
  issuerCommit2Cid <- deposit operator inv2 issuer public (qty 35_000_000.00 usdCommit) issuerCommitAccount2
  issuerCommit3Cid <- deposit operator inv3 issuer public (qty 40_000_000.00 usdCommit) issuerCommitAccount3

  inv1CashCid      <- deposit operator ta inv1 public (qty 200_000_000.00 usd) inv1CashAccount
  inv2CashCid      <- deposit operator ta inv2 public (qty 200_000_000.00 usd) inv2CashAccount
  inv3CashCid      <- deposit operator ta inv3 public (qty 200_000_000.00 usd) inv3CashAccount

  inv1UncommitedCid   <- deposit operator inv1 inv1 public (qty 60_000_000.00 usdCommit) inv1UncommittedAccount
  inv2UncommitedCid   <- deposit operator inv2 inv2 public (qty 70_000_000.00 usdCommit) inv2UncommittedAccount
  inv3UncommitedCid   <- deposit operator inv3 inv3 public (qty 90_000_000.00 usdCommit) inv3UncommittedAccount

  -- inv1Shares1Cid    <- deposit operator ta inv1 public (qty 25_000_000.00 pe1) inv1SecAccount
  -- inv2Shares1Cid    <- deposit operator ta inv2 public (qty 35_000_000.00 pe1) inv2SecAccount
  -- inv3Shares1Cid    <- deposit operator ta inv3 public (qty 40_000_000.00 pe1) inv3SecAccount
  -- issuerShares1Cid  <- deposit operator ta issuer public (qty 1_000_00.00 pe1) issuerSecAccount

  (_, ad1) <- issue operator ta issuer public (Instrument.qty 1_000_000.0 pe1)   issuerSecAccount

  -- Issuances (Test)
  -- (_, invCommitHolding1) <- issue operator inv1 inv1 public (qty 50_000_000.00 usdCommit) $ inv1UncommittedAccount
  -- (_, issuerPe2Holding) <- issue operator ta issuer public (qty 80_000_000.00 pe2) $ issuerSecAccount

  -- Capital Call (Test)

  -- declareCapitalCall : Party -> Party -> Party -> Party -> InstrumentKey -> InstrumentKey -> Time -> Numeric 10 -> Script (ContractId Effect.I)
  -- declareCapitalCall operator provider issuer public commitment ccy effectiveTime amount
  capitalCallEffectId <- declareCapitalCall operator inv1 admin public usdCommit usd t 5_000_000.0

  -- Need to do a split and expose first
  --(batchCid, instructionCids) <- claimEffect operator inv1 admin public capitalCallEffectId [issuerCommit1Cid] $ Id "Round 1"

  -- Workflows
  let
    doAuction = do
      let quantity = Instrument.qty 1_000_000.0 pe1
      auctionCid        <- createAuction operator ta issuer public "AUCTION1" quantity usd 0.95 (coerceContractId ad1) issuerCashAccount
      inv1CollateralCid <- coerceContractId <$> getHolding inv1 (Instrument.qty 500_000.0 usd)
      inv2CollateralCid <- coerceContractId <$> getHolding inv2 (Instrument.qty 392_000.0 usd)
      inv3CollateralCid <- coerceContractId <$> getHolding inv3 (Instrument.qty 297_000.0 usd)
      inv1BidCid        <- createAuctionBid operator ta inv1 public auctionCid 500_000.0 1.0  inv1CollateralCid inv1SecAccount
      inv2BidCid        <- createAuctionBid operator ta inv2 public auctionCid 400_000.0 0.98 inv2CollateralCid inv2SecAccount
      inv3BidCid        <- createAuctionBid operator ta inv3 public auctionCid 300_000.0 0.99 inv3CollateralCid inv3SecAccount
      processAuction operator ta issuer public auctionCid [inv1BidCid, inv2BidCid, inv3BidCid]

    
  doAuction
  --doTrade
  pure parties