module Daml.Finance.Setup.Scenario.PrivateEquity where

import DA.Map (empty, fromList)
import DA.Set (singleton)

import Daml.Script 

import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Settlement.Hierarchy qualified as Settlement (Hierarchy(..))

import Daml.Finance.Setup.Util.Common
import Daml.Finance.Setup.Util.Role
import Daml.Finance.Setup.Util.Service
import Daml.Finance.Setup.Util.Workflow
import Daml.Finance.Setup.Payoff
import DA.Foldable (mapA_)
import DA.Date
import DA.Time (time)
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Interface.Types.Common.Types (Id(..))
-- import Daml.Finance.Interface.Util.Disclosure qualified as Disclosure (AddObservers(..), I)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I, Split(..))
import qualified DA.List as List (delete)

import Daml.Finance.App.Distribution.PEDistribution.Model qualified as PEDistribution
import Daml.Finance.App.Distribution.PEDistribution.Service qualified as PEDistribution

run: Script [PartyInfo]
run = do 
  let scenario = "Private Equity"
  parties <- allocateParties scenario ["Operator", "FundManager", "Admin", "TransferAgent", "WealthManager", "Investor1", "Investor2", "Investor3"] "Public"
  let 
    all@[operator, issuer, admin, ta, wm, inv1, inv2, inv3, public] = map (.id) parties 
    pub = fromList [("Public", singleton public)]
    investorNames = [
      ("Investor1", inv1),
      ("Investor2", inv2),
      ("Investor3", inv3)]

  -- Factories
  let 
    assetLabels = ["PE1", "PE2", "PE3"]
    settlementPaths = [[issuer], [inv1], [inv2], [inv3]]
    cashRoute = Settlement.Hierarchy 
      with 
        rootCustodian = ta
        pathsToRootCustodian = List.delete [ta] settlementPaths
    secRoute = Settlement.Hierarchy 
      with 
        rootCustodian = issuer 
        pathsToRootCustodian = List.delete [issuer] settlementPaths
    commitments = map (<>"-COMMITMENT") assetLabels
    
    commitmentPaths = map (\(rootCustodian, i) -> (i, Settlement.Hierarchy with pathsToRootCustodian = List.delete [rootCustodian] settlementPaths; .. )) [
      (inv1, "PE1-COMMITMENT"),
      (inv2, "PE1-COMMITMENT"),
      (inv3, "PE1-COMMITMENT")]

    [commitmentPath1, commitmentPath2, commitmentPath3] = commitmentPaths

    paths = fromList $ [("USD", cashRoute)] ++ commitmentPaths ++ map (\a -> (a, secRoute)) assetLabels

  accountFactoryCid<- toInterfaceContractId 
    <$> submit operator do createCmd Account.Factory  with provider = operator; observers = pub 
  holdingFactoryCid <- toInterfaceContractId
    <$> submit operator do createCmd Fungible.Factory with provider = operator; observers = pub 

  -- Roles 
  createOperatorRole operator
  createDistributorRole operator ta
  let 
    custodianRoles = [inv1, inv2, inv3, ta, admin, issuer] 
  mapA_ (createCustodianRole operator) custodianRoles
  -- createDistributorRole   operator admin 

  -- Services 
  -- Custody Services
  let 
    cashPath = [("USD", cashRoute)]
    secPath = map (\a -> (a, secRoute)) assetLabels
    custodyServices = [
      (inv1, issuer, [commitmentPath1]++cashPath), 
      (inv2, issuer, [commitmentPath2]++cashPath), 
      (inv3, issuer, [commitmentPath3]++cashPath),
      (inv1, inv1, [commitmentPath1]), 
      (inv2, inv2, [commitmentPath2]), 
      (inv3, inv3, [commitmentPath3]),
      (ta, issuer, cashPath), 
      (ta, inv1, cashPath),
      (ta, inv2, cashPath), 
      (ta, inv3, cashPath),
      (admin, inv1, []),
      (admin, inv2, []),
      (admin, inv3, []),
      (admin, issuer, []),
      (issuer, issuer, secPath),
      (issuer, inv1, secPath),
      (issuer, inv2, secPath),
      (issuer, inv3, secPath)]

  mapA_ (\(provider, customer, p) -> createCustodyService 
    operator provider customer (fromList p) accountFactoryCid holdingFactoryCid) custodyServices
  
  --issuance services
  let 
    issuanceServices = [
      (inv1, inv1),
      (inv2, inv2), 
      (inv3, inv3), 
      (issuer, issuer)]

  mapA_ (\(provider, customer) -> do 
    createIssuanceService operator provider customer 
    createIssuanceAutoService operator provider customer) issuanceServices

  --lifecycle services
  let 
    lifecycleServices = [
      (inv1, admin), 
      (inv2, admin), 
      (inv3, admin),
      (inv1, issuer), 
      (inv2, issuer), 
      (inv3, issuer)]

  mapA_ (\(provider, customer) -> createLifecycleService operator provider customer public) lifecycleServices
  
  -- Structuring service 
  createStructuringService operator admin issuer 
  createStructuringAutoService operator admin issuer

 -- Hardcode three auction settlement accounts into the Auction Service
  -- createAuctionService          operator issuer       issuer paths
  -- createAuctionAutoService      operator issuer       issuer
  -- createBiddingService          operator issuer       inv1
  -- createBiddingAutoService      operator issuer       inv1
  -- createBiddingService          operator issuer       inv2
  -- createBiddingAutoService      operator issuer       inv2
  -- createBiddingService          operator issuer       inv3
  -- createBiddingAutoService      operator issuer       inv3

  createPEDistributionService operator ta issuer paths

  createPEBiddingService          operator ta       inv1
  createPEBiddingAutoService      operator ta       inv1
  createPEBiddingService          operator ta       inv2
  createPEBiddingAutoService      operator ta       inv2
  createPEBiddingService          operator ta       inv3
  createPEBiddingAutoService      operator ta       inv3
  -- Time 
  t <- getTime 
  let 
    today = toDateUTC t 
    todayTime = time today 0 0 0
    tt d = time d 0 0 0 
    epoch = tt $ date 1970 Jan 1
    (ty, tm, td) = toGregorian today 
  (clockCid, eventCid) <- createClockAndEvent all today $ singleton public

  -- Instruments 
  usd       <- originateToken ta ta pub epoch "USD" "United States Dollar"
  usdCommit1 <- originateGeneric admin issuer pub epoch "PE1-COMMITMENT" "USD Commitment to PE1" $ capitalCommitment usd epoch
  pe1        <- originateEquity issuer issuer pub epoch "PE1" "Private Equity Fund 1 Shares" 
  pe2        <- originateEquity issuer issuer pub epoch "PE2" "Private Equity Fund 2 Shares"
  pe3        <- originateEquity issuer issuer pub epoch "PE3" "Private Equity Fund 3 Shares"
  usdCommit2 <- originateGeneric admin issuer pub epoch "PE2-COMMITMENT" "USD Commitment to PE2" $ capitalCommitment usd epoch
  usdCommit3 <- originateGeneric admin issuer pub epoch "PE3-COMMITMENT" "USD Commitment to PE3" $ capitalCommitment usd epoch
  let usdCommit = usdCommit1
  -- Accounts
  let 
    createAccount' provider customer name obs = createAccount operator provider customer public name obs
    adminObs = fromList [("Admin", singleton admin), ("FundManager", singleton issuer)]

  -- Commit Accounts
  issuerCommitAccount1      <- createAccount'  inv1 issuer "FundManager@Inv1|Commitments" adminObs
  issuerCommitAccount2      <- createAccount'  inv2 issuer "FundManager@Inv2|Commitments" adminObs
  issuerCommitAccount3      <- createAccount'  inv3 issuer "FundManager@Inv3|Commitments" adminObs
  -- 'Dummy' account to enable creation of an auction in the UI but not used to hold commitments
  issuerCommitAccountD      <- createAccount'  admin issuer "FundManager@Admin|Commitments" adminObs

  inv1UncommittedAccount <- createAccount'  inv1 inv1   "Investor1|Uncommitted" empty 
  inv2UncommittedAccount <- createAccount'  inv2 inv2   "Investor2|Uncommitted" empty 
  inv3UncommittedAccount <- createAccount'  inv3 inv3   "Investor3|Uncommitted" empty 

  -- Cash Accounts 
  issuerCashAccount         <- createAccount' ta issuer "FundManager@TA|Cash" empty 
  inv1CashAccount           <- createAccount' ta inv1   "Investor1@TA|Cash" empty 
  inv2CashAccount           <- createAccount' ta inv2   "Investor2@TA|Cash" empty
  inv3CashAccount           <- createAccount' ta inv3   "Investor3@TA|Cash" empty

  -- Security Accounts 
  issuerSecAccount          <- createAccount' issuer issuer "FundManager@Admin|Securities" empty 
  inv1SecAccount            <- createAccount' issuer inv1   "Investor1@Admin|Securities" empty 
  inv2SecAccount            <- createAccount' issuer inv2   "Investor2@Admin|Securities" empty
  inv3SecAccount            <- createAccount' issuer inv3   "Investor3@Admin|Securities" empty

  -- Directories 
  createAccountDirectory issuer [(usd, issuerCashAccount)]    $singleton public 
  createAccountDirectory inv1 [(usd, inv1CashAccount)]        $singleton public
  createAccountDirectory inv2 [(usd, inv2CashAccount)]        $singleton public
  createAccountDirectory inv3 [(usd, inv3CashAccount)]        $singleton public

  -- -- Holdings 
  -- issuerCommit1Cid <- deposit operator inv1 issuer public (qty 25_000_000.00 usdCommit) issuerCommitAccount1
  -- issuerCommit2Cid <- deposit operator inv2 issuer public (qty 35_000_000.00 usdCommit) issuerCommitAccount2
  -- issuerCommit3Cid <- deposit operator inv3 issuer public (qty 40_000_000.00 usdCommit) issuerCommitAccount3

  inv1CashCid      <- deposit operator ta inv1 public (qty 200_000_000.00 usd) inv1CashAccount
  inv2CashCid      <- deposit operator ta inv2 public (qty 200_000_000.00 usd) inv2CashAccount
  inv3CashCid      <- deposit operator ta inv3 public (qty 200_000_000.00 usd) inv3CashAccount

  inv1UncommitedCid   <- deposit operator inv1 inv1 public (qty 60_000_000.00 usdCommit) inv1UncommittedAccount
  inv2UncommitedCid   <- deposit operator inv2 inv2 public (qty 70_000_000.00 usdCommit) inv2UncommittedAccount
  inv3UncommitedCid   <- deposit operator inv3 inv3 public (qty 90_000_000.00 usdCommit) inv3UncommittedAccount

  -- inv1Shares1Cid    <- deposit operator issuer inv1 public (qty 25_000_000.00 pe1) inv1SecAccount
  -- inv2Shares1Cid    <- deposit operator issuer inv2 public (qty 35_000_000.00 pe1) inv2SecAccount
  -- inv3Shares1Cid    <- deposit operator issuer inv3 public (qty 40_000_000.00 pe1) inv3SecAccount
  issuerShares1Cid  <- deposit operator issuer issuer public (qty 1_000_00.00 pe1) issuerSecAccount

  -- Issuances (Test)
  (_, ad1) <- issue operator issuer issuer public (qty 1_000_000.0 pe1)   issuerSecAccount
  -- (_, invCommitHolding1) <- issue operator inv1 inv1 public (qty 50_000_000.00 usdCommit) $ inv1UncommittedAccount
  -- (_, issuerPe2Holding) <- issue operator ta issuer public (qty 80_000_000.00 pe2) $ issuerSecAccount

  -- Capital Call (Test)

  -- declareCapitalCall : Party -> Party -> Party -> Party -> InstrumentKey -> InstrumentKey -> Time -> Numeric 10 -> Script (ContractId Effect.I)
  -- declareCapitalCall operator provider issuer public commitment ccy effectiveTime amount

  -- COMMENTED LEVE'S CODE BELOW
  -- capitalCallEffectId <- declareCapitalCall operator inv1 issuer public usdCommit usd t 5_000_000.0
  -- claimCapitalCallEffect operator inv1 issuer public capitalCallEffectId 5_000_000.00 (coerceContractId issuerCommit1Cid: ContractId Fungible.I) $ Id "Round 1"

  -- capitalCallEffectId <- declareCapitalCall operator inv2 issuer public usdCommit usd t 7_000_000.0
  -- claimCapitalCallEffect operator inv2 issuer public capitalCallEffectId 7_000_000.00 (coerceContractId issuerCommit2Cid: ContractId Fungible.I) $ Id "Round 1"

  -- capitalCallEffectId <- declareCapitalCall operator inv3 issuer public usdCommit usd t 8_000_000.0
  -- claimCapitalCallEffect operator inv3 issuer public capitalCallEffectId 8_000_000.00 (coerceContractId issuerCommit3Cid: ContractId Fungible.I) $ Id "Round 1"
  -- END LEVE'S COMMENTED CODE


  -- Need to do a split and expose first
  --(batchCid, instructionCids) <- claimEffect operator inv1 admin public capitalCallEffectId [issuerCommit1Cid] $ Id "Round 1"

  -- PE Distribution (Test)
  let quantity = qty 1_000_000.0 pe1
  -- Auction goes via Workflow.daml but Offering uses service directly
  -- offeringCid <- submit issuer do
  --   let
  --     offeringId = "OFFERING-PE1"
  --   exerciseByKeyCmd @PEDistribution.Service (operator, issuer, issuer) PEDistribution.CreatePEDistribution
  --     with
  --       offeringId
  --       asset
  --       price
  --       customerHoldingCid = coerceContractId issuerAssetCid
  --       customerAccount = issuerCashAccount
  --       observers = singleton public
  auctionCid        <- createPEDistribution operator ta issuer public "DISTRIBUTION1" quantity usdCommit 1.0 (coerceContractId ad1) issuerCashAccount
  inv1CollateralCid <- coerceContractId <$> getHolding inv1 (qty 500_010.0 usdCommit)
  inv2CollateralCid <- coerceContractId <$> getHolding inv2 (qty 392_000.0 usdCommit)
  inv3CollateralCid <- coerceContractId <$> getHolding inv3 (qty 297_000.0 usdCommit)
  inv1BidCid        <- createPEDistributionBid operator ta inv1 public auctionCid 500_010.0 1.0  inv1CollateralCid inv1SecAccount
  inv2BidCid        <- createPEDistributionBid operator ta inv2 public auctionCid 392_000.0 1.0 inv2CollateralCid inv2SecAccount
  inv3BidCid        <- createPEDistributionBid operator ta inv3 public auctionCid 297_000.0 1.0 inv3CollateralCid inv3SecAccount
  --processPEDistribution operator ta issuer public auctionCid [inv1BidCid, inv2BidCid, inv3BidCid]

  -- doAuction
  pure parties
{-
fst <$> exercise instructionCid Instruction.Allocate with actors = singleton customer; allocation = T.Pledge $ toInterfaceContractId transferableCid

  Bid {
    operator = 'Operator-Private Equity', 
    provider = 'FundManager-Private Equity', 
    customer = 'Investor1-Private Equity', 
    issuer = 'FundManager-Private Equity', 
    details = Details {
      quantity = Quantity {
        unit = InstrumentKey {
          depository = 'Admin-Private Equity', 
          issuer = 'FundManager-Private Equity', 
          id = PE1, 
          version = "0"
        }, 
        amount = 500010.0
      }, 
      price = Quantity {
        unit = InstrumentKey {
          depository = 'Admin-Private Equity', 
          issuer = 'FundManager-Private Equity', 
          id = PE1-COMMITMENT, 
          version = "0"
        }, 
        amount = 1.0
      }, 
      time = 1970-01-01T00:00:00Z
    }, 
    auctionId = "AUCTION1", 
    collateralCid = <contract-id>, 
    receivableAccount = AccountKey {
      custodian = 'FundManager-Private Equity', 
      owner = 'Investor1-Private Equity', 
      id = Investor1@Admin|Securities
    }, 
    status = FullAllocation {price = 1.0}
  }
-}