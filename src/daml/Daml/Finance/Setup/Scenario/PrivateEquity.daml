module Daml.Finance.Setup.Scenario.PrivateEquity where

import DA.Map (empty, fromList)
import DA.Set (singleton)

import Daml.Script 

import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Settlement.Hierarchy qualified as Settlement (Hierarchy(..))

import Daml.Finance.Setup.Util.Common
import Daml.Finance.Setup.Util.Role
import Daml.Finance.Setup.Util.Service
import Daml.Finance.Setup.Util.Workflow
import Daml.Finance.Setup.Payoff
import DA.Foldable (mapA_)
import DA.Date
import DA.Time (time)
import Daml.Finance.Interface.Util.Common (qty)
import DA.List ((!!))

run: Script [PartyInfo]
run = do 
  let scenario = "Private Equity"
  parties <- allocateParties scenario ["Operator", "Issuer", "Admin", "TransferAgent", "WealthManager", "Investor1", "Investor2", "Investor3"] "Public"
  let 
    all@[operator, issuer, admin, ta, wm, inv1, inv2, inv3, public] = map (.id) parties 
    pub = fromList [("Public", singleton public)]
    investorNames = [
      ("Investor1", inv1),
      ("Investor2", inv2),
      ("Investor3", inv3)]

  -- Factories
  let 
    assetLabels = ["PE1", "PE2", "PE3"]
    settlementPaths = [[ta], [admin], [wm]]
    cashRoute = Settlement.Hierarchy 
      with 
        rootCustodian = ta
        pathsToRootCustodian = settlementPaths 
    secRoute = Settlement.Hierarchy 
      with 
        rootCustodian = ta 
        pathsToRootCustodian = settlementPaths 
    paths = fromList $ ("USD", cashRoute) :: map (\a -> (a, secRoute)) assetLabels
  accountFactoryCid<- toInterfaceContractId 
    <$> submit operator do createCmd Account.Factory  with provider = operator; observers = pub 
  holdingFactoryCid <- toInterfaceContractId
    <$> submit operator do createCmd Fungible.Factory with provider = operator; observers = pub 

  -- Roles 
  createOperatorRole      operator 
  createCustodianRole     operator ta 
  createCustodianRole     operator admin
  createDistributorRole   operator admin 

  -- Services 

  let 
    custodyServices = [
      (ta, wm),
      (ta, admin), 
      (ta, issuer), 
      (admin, inv1), 
      (admin, inv2), 
      (admin, inv3),
      (admin, issuer),
      (ta, inv1), 
      (ta, inv2), 
      (ta, inv3)]

  -- custody services
  mapA_ (\(provider, customer) -> createCustodyService 
    operator provider customer paths accountFactoryCid holdingFactoryCid) custodyServices

  -- Admin is going to Structure Equities and Capital Commitments.
  createStructuringService      operator ta admin 
  createStructuringAutoService  operator ta admin

  -- Issuer will issue PE Tokens. 
  -- createIssuanceService         operator admin issuer 
  -- createIssuanceAutoService     operator admin issuer         

  -- WMs will issue Capital commitments 
  -- createIssuanceService         operator admin wm
  -- createIssuanceAutoService     operator admin wm 

  -- Investors will issuer their own capital commitments 
  mapA_ (\(_, inv) -> do 
    createIssuanceService         operator admin inv 
    createStructuringAutoService  operator admin inv) (investorNames)

  createLifecycleService        operator ta issuer public 
  createLifecycleService        operator admin issuer public 

  --mapA_ (\(_, inv) -> createLifecycleService operator admin inv public) investorNames

  mapA_ (\(provider, customer) -> createSettlementService 
    operator provider customer paths ) custodyServices
  
  -- Time 
  t <- getTime 
  let 
    today = toDateUTC t 
    todayTime = time today 0 0 0
    tt d = time d 0 0 0 
    epoch = tt $ date 1970 Jan 1
    (ty, tm, td) = toGregorian today 
  (clockCid, eventCid) <- createClockAndEvent all today $ singleton public

  -- Instruments 
  usd       <- originateToken ta ta pub epoch "USD" "United States Dollar"
  usdCommits <- mapA (\(name, inv) -> originateGeneric admin inv pub epoch ("USD-COMMIT-" <> name) (name <>" USD Capital Commitment") $ capitalCommitment usd epoch) investorNames
  pe1        <- originateEquity admin issuer pub epoch "PE1" "Private Equity Fund 1" 
  pe2        <- originateEquity admin issuer pub epoch "PE2" "Private Equity Fund 2"
  pe3        <- originateEquity admin issuer pub epoch "PE3" "Private Equity Fund 3"
  
  -- Accounts
  let 
    createAccount' provider customer name obs = createAccount operator provider customer public name obs

  issuerCashAccount     <- createAccount'   ta issuer "Issuer@TA|Cash"  empty 
  issuerCashCid         <- deposit operator ta issuer public (qty 50_000_000.00 usd) issuerCashAccount
  adminCashAccount      <- createAccount'   ta admin  "Admin@TA|Cash"   empty
  adminCashCid          <- deposit operator ta admin  public (qty 100_000_000.00 usd) adminCashAccount

  issuerSecAccount     <- createAccount' ta issuer "Issuer@TA|Securities"  empty 
  issuerCommitAccount  <- createAccount' admin issuer "Issuer@Admin|Commitments" empty
  adminSecAccount      <- createAccount' ta admin  "Admin@TA|Securities"   empty
  invSecAccounts       <- mapA (\(name, party) -> createAccount' admin party (name <>"@WM|Securities") $ fromList [(name, singleton party), ("Admin", singleton admin)]) investorNames
  invCashAccounts      <- mapA (\(name, party) -> createAccount' ta    party (name <>"@WM|Cash") $ fromList [(name, singleton party), ("Admin", singleton admin)]) investorNames

  deposit operator ta inv1 public (qty 80_000_000.00 usd) $invCashAccounts !! 0 
  deposit operator ta inv2 public (qty 80_000_000.00 usd) $invCashAccounts !! 1
  deposit operator ta inv3 public (qty 80_000_000.00 usd) $invCashAccounts !! 2

  (_, invCommitHolding1) <- issue operator admin inv1 public (qty 50_000_000.00 (usdCommits!!0)) $ invSecAccounts!!0
  (_, invCommitHolding2) <- issue operator admin inv2 public (qty 50_000_000.00 (usdCommits!!1)) $ invSecAccounts!!1
  (_, invCommitHolding3) <- issue operator admin inv3 public (qty 50_000_000.00 (usdCommits!!2)) $ invSecAccounts!!2

  (toTransfer1, Some invCommitHolding1) <- split inv1 20_000_000.00 (coerceContractId invCommitHolding1) 
  (toTransfer2, Some invCommitHolding2) <- split inv2 30_000_000.00 (coerceContractId invCommitHolding2)
  (toTransfer3, Some invCommitHolding3) <- split inv3 40_000_000.00 (coerceContractId invCommitHolding3)

  transfer inv1 issuerCommitAccount public $coerceContractId toTransfer1
  transfer inv2 issuerCommitAccount public $coerceContractId toTransfer2
  transfer inv3 issuerCommitAccount public $coerceContractId toTransfer3

  pure parties