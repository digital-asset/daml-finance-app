-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Setup.Scenario.MoneyMarketTokenization where

import DA.Date (Month(..), date, toDateUTC)
import DA.Map (empty, fromList)
import DA.Set (singleton)
import DA.Time (time)
import Daml.Finance.App.Distribution.Fund.Model (Fund(..))
import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Settlement.Hierarchy qualified as Settlement (Hierarchy(..))
import Daml.Finance.Setup.Util.Common
import Daml.Finance.Setup.Util.Role
import Daml.Finance.Setup.Util.Service
import Daml.Finance.Setup.Util.Workflow
import Daml.Script
import DA.Foldable (mapA_)
import DA.List ((!!))
import qualified DA.Map as Map

xx : a -> [b] -> [(a, b)]
xx f ys = map (\y -> (f, y)) ys

run : Script [PartyInfo]
run = do
  let 
    scenario = "Money Market Tokenization"
    investorNames = ["HedgeFund1", "HedgeFund2", "PrimeBroker", "SwapsDealer", "InsuranceCo"]
  parties <- allocateParties scenario (["Operator", "CashRail", "TransferAgent", "AssetManager", "Registry", "CollateralClearer"] ++ investorNames) "Public"
  let
    all@[operator, cashProvider, ta, am, registry, cc, inv0, inv1, inv2, inv3, inv4, public] = map (.id) parties
    pub = fromList [("Public", singleton public)]
    inv = [inv0, inv1, inv2, inv3, inv4]

  -- Factories
  let
    assets = ["MMF1", "MMF2", "MMF3", "MMF4"]
    settlementPaths = [[registry], [ta], [am], [inv!!0, ta], [inv!!1, ta], [inv!!2, ta], [inv!!3, ta], [inv!!4, ta]]
    cashRoute = Settlement.Hierarchy with rootCustodian = cashProvider; pathsToRootCustodian = settlementPaths
    secRoute = Settlement.Hierarchy with rootCustodian = registry; pathsToRootCustodian = settlementPaths
    paths = fromList $ ("USD", cashRoute) :: map (\a -> (a, secRoute)) assets
  accountFactoryCid         <- toInterfaceContractId <$> submit operator do createCmd Account.Factory    with provider = operator; observers = pub
  holdingFactoryCid         <- toInterfaceContractId <$> submit operator do createCmd Fungible.Factory   with provider = operator; observers = pub

  -- Roles
  createOperatorRole operator
  createCustodianRole operator cashProvider
  createCustodianRole operator registry
  createCustodianRole operator ta
  createDistributorRole operator ta
  createDistributorRole operator am
  createCollateralClearerRole operator cc

  -- Services
  let 
    custodyServiceParties = (cashProvider `xx` [ta, registry]) ++ (ta `xx` inv) ++ (registry `xx` [ta, am])
  mapA_ (\(by, to) -> createCustodyService operator by to paths accountFactoryCid holdingFactoryCid) custodyServiceParties

  createIssuanceService           operator registry    am
  createIssuanceAutoService       operator registry    am
  createStructuringService        operator registry    am
  createStructuringAutoService    operator registry    am
  mapA_ (createInvestmentService  operator ta)          inv
  createFundService               operator am           ta        paths
  createLifecycleService          operator registry    am        public
  mapA_ (createCollateralService operator cc) inv

  -- Accounts
  taCashAccount         <- createAccount operator cashProvider  ta        public "TransferAgent@CashRail/Cash"        $ fromList [("AM", singleton am)]
  custodianCashAccount  <- createAccount operator cashProvider  registry public "Custodian@CashRail/Cash"           $ fromList [("AM", singleton am)]
  let
    invCashAccountNames = (<> "@TransferAgent/Cash") <$> investorNames
  invCashAccounts <- mapA (\(inv, name) -> createAccount operator ta inv public name $ fromList [("AM", singleton am)]) (zip inv invCashAccountNames)

  taSecAccount          <- createAccount operator registry     ta        public "TransferAgent@Custodian/Securities"      $ fromList [("AM", singleton am)]
  amSecAccount          <- createAccount operator registry     am        public "FundManager@Custodian/Securities" empty

  let 
    invSecAccountNames =  (<> "@TransferAgent/Securities") <$> investorNames 
  invSecAccounts <- mapA (\(inv, name) -> createAccount operator ta inv public name $ fromList [("AM", singleton am)]) (zip inv invSecAccountNames)

  -- Time
  t <- getTime
  let
    today = toDateUTC t
    todayTime = time today 0 0 0
    tt d = time d 0 0 0
    epoch = tt $ date 1970 Jan 1

  -- Instruments
  usd   <- originateToken                    cashProvider  cashProvider  pub epoch "USD"   "United States Dollar"
  fund1 <- originateEquity                    registry     am            pub epoch "MMF1" "MMF1 Units"
  fund2 <- originateEquity                    registry     am            pub epoch "MMF2" "MMF2 Units"
  fund3 <- originateEquity                    registry     am            pub epoch "MMF3" "MMF3 Units"

  -- Holdings
  taCashCid   <- deposit operator cashProvider ta    public (Instrument.qty  300_000_000.0 usd) taCashAccount
  inv0CashCid <- deposit operator ta           (inv!!0)  public (Instrument.qty  100_000_000.0 usd) $ invCashAccounts!!0
  inv1CashCid <- deposit operator ta           (inv!!1)  public (Instrument.qty  100_000_000.0 usd) $ invCashAccounts!!1
  inv2CashCid <- deposit operator ta           (inv!!2)  public (Instrument.qty  100_000_000.0 usd) $ invCashAccounts!!2

  -- -- Data
  fund1Cid <- submitMulti [operator, registry, am] [] do createCmd Fund with operator; custodian = registry; manager = am; id = Id "MMF1"; description = "Money-Market Fund 1"; instrument = fund1; currency = usd; custodianCashAccount; managerFundAccount = amSecAccount; totalUnits =  10_100_000_000.0; observers = singleton public
  fund2Cid <- submitMulti [operator, registry, am] [] do createCmd Fund with operator; custodian = registry; manager = am; id = Id "MMF2"; description = "Money-Market Fund 2"; instrument = fund2; currency = usd; custodianCashAccount; managerFundAccount = amSecAccount; totalUnits =  12_500_000_000.0; observers = singleton public
  fund3Cid <- submitMulti [operator, registry, am] [] do createCmd Fund with operator; custodian = registry; manager = am; id = Id "MMF3"; description = "Money-Market Fund 3"; instrument = fund3; currency = usd; custodianCashAccount; managerFundAccount = amSecAccount; totalUnits =  25_500_000_000.0; observers = singleton public
  --fund4Cid <- submitMulti [operator, registry, am] [] do createCmd Fund with operator; custodian = registry; manager = am; id = Id "MMF4"; description = "Money-Market Fund 4"; instrument = fund4; currency = usd; custodianCashAccount; managerFundAccount = amSecAccount; totalUnits =  10_000_000_000.0; observers = singleton public
  navFund1Cid <- createObservation am "NAV_MMF1_USD" [ (todayTime,   10_100_000_000.0) ] pub
  navFund2Cid <- createObservation am "NAV_MMF2_USD" [ (todayTime,   12_500_000_000.0) ] pub
  navFund3Cid <- createObservation am "NAV_MMF3_USD" [ (todayTime,   25_500_000_000.0) ] pub
  navFund4Cid <- createObservation am "NAV_MMF4_USD" [ (todayTime,   10_000_000_000.0) ] pub

  createAccountDirectory registry  [(usd, custodianCashAccount)] $ singleton public
  createAccountDirectory ta         [(usd, taCashAccount), (fund1, taSecAccount), (fund2, taSecAccount), (fund3, taSecAccount)] $ singleton public
  createAccountDirectory (inv!!0)       [(usd, invCashAccounts!!0), (fund1, invSecAccounts!!0), (fund2, invSecAccounts!!0), (fund3, invSecAccounts!!0)] $ singleton public
  createAccountDirectory (inv!!1)      [(usd, invCashAccounts!!1), (fund1, invSecAccounts!!1), (fund2, invSecAccounts!!1), (fund3, invSecAccounts!!1)] $ singleton public
  createAccountDirectory (inv!!2)       [(usd, invCashAccounts!!2), (fund1, invSecAccounts!!2), (fund2, invSecAccounts!!2), (fund3, invSecAccounts!!2)] $ singleton public
  createAccountDirectory (inv!!3)       [(usd, invCashAccounts!!3), (fund1, invSecAccounts!!3), (fund2, invSecAccounts!!3), (fund3, invSecAccounts!!3)] $ singleton public
  createAccountDirectory (inv!!4)       [(usd, invCashAccounts!!4), (fund1, invSecAccounts!!4), (fund2, invSecAccounts!!4), (fund3, invSecAccounts!!4)] $ singleton public

  -- CSAs 
  let 
    haircuts = fromList [(fund1, 0.98), (fund2, 0.98), (fund3, 0.98)]
  csa20 <- signBilateralCsa operator cc (inv!!2) (inv!!0) "CSA PB HF1" (date 2017 Dec 1) usd 1_000_000.00 1_000.00 0.0 haircuts $ fromList [("TA", singleton ta)]
  csa21 <- signBilateralCsa operator cc (inv!!2) (inv!!1) "CSA PB HF2" (date 2017 Dec 1) usd 1_000_000.00 1_000.00 0.0 haircuts $ fromList [("TA", singleton ta)]
  csa23 <- signBilateralCsa operator cc (inv!!2) (inv!!3) "CSA PB SWP" (date 2017 Dec 1) usd 1_000_000.00 1_000.00 0.0 haircuts $ fromList [("TA", singleton ta)]

  -- -- Workflows
  -- let
  --   doDistribution = do
  --     ir1Cid <- createInvestmentRequest operator ta inv!!0 public "REQ-MMF1-INV1" today fund1Cid (coerceContractId inv!!0CashCid)
  --     ir2Cid <- createInvestmentRequest operator ta inv!!1 public "REQ-MMF2-INV2" today fund1Cid (coerceContractId inv!!1CashCid)
  --     ir3Cid <- createInvestmentRequest operator ta inv!!2 public "REQ-MMF3-INV3" today fund1Cid (coerceContractId inv!!2CashCid)
  --     pirCid <- poolInvestmentRequests operator am ta public "REQ-MMF1-POOLED" today fund1Cid (coerceContractId amCashCid) [ir1Cid, ir2Cid, ir3Cid]
  --     fulfillPooledInvestmentRequest operator am ta public fund1Cid pirCid navFund1Cid
  -- -- doDistribution

  pure parties

-- "CONTRACT_KEY_NOT_FOUND(11,7524fc1b): dependency error: couldn't find key: GlobalKey(8c0dc42d59ca5a69b73bc6173a8fee8b4c003fc2a868384b690ee50772a540c1:Daml.Finance.App.Data.AccountDirectory:AccountDirectory, ValueParty(TransferAgent-Money Market Tokenization::1220691b7f72e3a672ea5c867997e7e7b9085136661bd13de33ab3de2d728129a3f5))"