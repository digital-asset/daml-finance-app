-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Setup.Scenario.MoneyMarketTokenization where

import DA.Date (Month(..), date, toDateUTC)
import DA.Map (empty, fromList)
import DA.Set (singleton)
import DA.Time (time)
import Daml.Finance.App.Distribution.Fund.Model (Fund(..))
import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (qty)
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Settlement.Hierarchy qualified as Settlement (Hierarchy(..))
import Daml.Finance.Setup.Util.Common
import Daml.Finance.Setup.Util.Role
import Daml.Finance.Setup.Util.Service
import Daml.Finance.Setup.Util.Workflow
import Daml.Script
import DA.Foldable (mapA_)
import DA.List ((!!))

xx : a -> [b] -> [(a, b)]
xx f ys = map (\y -> (f, y)) ys

run : Script [PartyInfo]
run = do
  let 
    scenario = "Money Market Tokenization"
    investorNames = ["HedgeFund1", "HedgeFund2", "PrimeBroker", "SwapsDealer", "InsuranceCo"]
  parties <- allocateParties scenario (["Operator", "CashRail", "TransferAgent", "FundManager", "Custodian"] ++ investorNames) "Public"
  let
    all@[operator, cashProvider, ta, fm, custodian, inv1, inv2, inv3, inv4, inv5, public] = map (.id) parties
    pub = fromList [("Public", singleton public)]
    investors = [inv1, inv2, inv3, inv4, inv5]

  -- Factories
  let
    assets = ["MMF1", "MMF2", "MMF3"]
    settlementPaths = [[custodian], [ta], [fm], [inv1, ta], [inv2, ta], [inv3, ta], [inv4, ta], [inv5, ta]]
    cashRoute = Settlement.Hierarchy with rootCustodian = cashProvider; pathsToRootCustodian = settlementPaths
    secRoute = Settlement.Hierarchy with rootCustodian = custodian; pathsToRootCustodian = settlementPaths
    paths = fromList $ ("USD", cashRoute) :: map (\a -> (a, secRoute)) assets
  accountFactoryCid         <- toInterfaceContractId <$> submit operator do createCmd Account.Factory    with provider = operator; observers = pub
  holdingFactoryCid         <- toInterfaceContractId <$> submit operator do createCmd Fungible.Factory   with provider = operator; observers = pub

  -- Roles
  createOperatorRole operator
  createCustodianRole operator cashProvider
  createCustodianRole operator custodian
  createCustodianRole operator ta
  createDistributorRole operator ta
  createDistributorRole operator fm

  -- Services
  let 
    custodyServiceParties = (cashProvider `xx` [ta, custodian]) ++ (ta `xx` investors) ++ (custodian `xx` [ta, fm])
  mapA_ (\(by, to) -> createCustodyService operator by to paths accountFactoryCid holdingFactoryCid) custodyServiceParties

  createIssuanceService           operator custodian    fm
  createIssuanceAutoService       operator custodian    fm
  createStructuringService        operator custodian    fm
  createStructuringAutoService    operator custodian    fm
  mapA_ (createInvestmentService  operator ta)          investors
  createFundService               operator fm           ta        paths
  createLifecycleService          operator custodian    fm        public

  -- Accounts
  taCashAccount         <- createAccount operator cashProvider  ta        public "TransferAgent@CashRail/Cash"        $ fromList [("FM", singleton fm)]
  custodianCashAccount  <- createAccount operator cashProvider  custodian public "Custodian@CashRail/Cash"           $ fromList [("FM", singleton fm)]
  let
    invCashAccountNames = (<> "@TransferAgent/Cash") <$> investorNames
  invCashAccounts <- mapA (\(inv, name) -> createAccount operator ta inv public name $ fromList [("FM", singleton fm)]) (zip investors invCashAccountNames)

  taSecAccount          <- createAccount operator custodian     ta        public "TransferAgent@Custodian/Securities"      $ fromList [("FM", singleton fm)]
  fmSecAccount          <- createAccount operator custodian     fm        public "FundManager@Custodian/Securities" empty

  let 
    invSecAccountNames =  (<> "@TransferAgent/Securities") <$> investorNames 
  invSecAccounts <- mapA (\(inv, name) -> createAccount operator ta inv public name $ fromList [("FM", singleton fm)]) (zip investors invSecAccountNames)

  -- Time
  t <- getTime
  let
    today = toDateUTC t
    todayTime = time today 0 0 0
    tt d = time d 0 0 0
    epoch = tt $ date 1970 Jan 1

  -- Instruments
  usd   <- originateToken                    cashProvider  cashProvider  pub epoch "USD"   "United States Dollar"
  fund1 <- originateEquity                    custodian     fm            pub epoch "MMF1" "MMF1 Units"
  fund2 <- originateEquity                    custodian     fm            pub epoch "MMF2" "MMF2 Units"
  fund3 <- originateEquity                    custodian     fm            pub epoch "MMF3" "MMF3 Units"

  -- Holdings
  taCashCid   <- deposit operator cashProvider ta    public (Instrument.qty 10_000_000.0 usd) taCashAccount
  inv1CashCid <- deposit operator ta           inv1  public (Instrument.qty  6_000_000.0 usd) $ invCashAccounts!!0
  inv2CashCid <- deposit operator ta           inv2  public (Instrument.qty  3_000_000.0 usd) $ invCashAccounts!!1
  inv3CashCid <- deposit operator ta           inv3  public (Instrument.qty  1_000_000.0 usd) $ invCashAccounts!!2

  -- -- Data
  fund1Cid <- submitMulti [operator, custodian, fm] [] do createCmd Fund with operator; custodian; manager = fm; id = Id "MMF1"; description = "Money-Market Fund 1"; instrument = fund1; currency = usd; custodianCashAccount; managerFundAccount = fmSecAccount; totalUnits =  1_000_000.0; observers = singleton public
  fund2Cid <- submitMulti [operator, custodian, fm] [] do createCmd Fund with operator; custodian; manager = fm; id = Id "MMF2"; description = "Money-Market Fund 2"; instrument = fund2; currency = usd; custodianCashAccount; managerFundAccount = fmSecAccount; totalUnits =  5_000_000.0; observers = singleton public
  fund3Cid <- submitMulti [operator, custodian, fm] [] do createCmd Fund with operator; custodian; manager = fm; id = Id "MMF3"; description = "Money-Market Fund 3"; instrument = fund3; currency = usd; custodianCashAccount; managerFundAccount = fmSecAccount; totalUnits = 15_000_000.0; observers = singleton public
  navFund1Cid <- createObservation fm "NAV_MMF1_USD" [ (todayTime,   100_000_000.0) ] pub
  navFund2Cid <- createObservation fm "NAV_MMF2_USD" [ (todayTime,   500_000_000.0) ] pub
  navFund3Cid <- createObservation fm "NAV_MMF3_USD" [ (todayTime, 1_500_000_000.0) ] pub

  createAccountDirectory custodian  [(usd, custodianCashAccount)] $ singleton public
  createAccountDirectory ta         [(usd, taCashAccount), (fund1, taSecAccount), (fund2, taSecAccount), (fund3, taSecAccount)] $ singleton public
  createAccountDirectory inv1       [(usd, invCashAccounts!!0), (fund1, invSecAccounts!!0), (fund2, invSecAccounts!!0), (fund3, invSecAccounts!!0)] $ singleton public
  createAccountDirectory inv2       [(usd, invCashAccounts!!1), (fund1, invSecAccounts!!1), (fund2, invSecAccounts!!1), (fund3, invSecAccounts!!1)] $ singleton public
  createAccountDirectory inv3       [(usd, invCashAccounts!!2), (fund1, invSecAccounts!!2), (fund2, invSecAccounts!!2), (fund3, invSecAccounts!!2)] $ singleton public
  createAccountDirectory inv4       [(usd, invCashAccounts!!3), (fund1, invSecAccounts!!3), (fund2, invSecAccounts!!3), (fund3, invSecAccounts!!3)] $ singleton public
  createAccountDirectory inv5       [(usd, invCashAccounts!!4), (fund1, invSecAccounts!!4), (fund2, invSecAccounts!!4), (fund3, invSecAccounts!!4)] $ singleton public


  -- -- Workflows
  -- let
  --   doDistribution = do
  --     ir1Cid <- createInvestmentRequest operator ta inv1 public "REQ-MMF1-INV1" today fund1Cid (coerceContractId inv1CashCid)
  --     ir2Cid <- createInvestmentRequest operator ta inv2 public "REQ-MMF2-INV2" today fund1Cid (coerceContractId inv2CashCid)
  --     ir3Cid <- createInvestmentRequest operator ta inv3 public "REQ-MMF3-INV3" today fund1Cid (coerceContractId inv3CashCid)
  --     pirCid <- poolInvestmentRequests operator fm ta public "REQ-MMF1-POOLED" today fund1Cid (coerceContractId amCashCid) [ir1Cid, ir2Cid, ir3Cid]
  --     fulfillPooledInvestmentRequest operator fm ta public fund1Cid pirCid navFund1Cid
  -- -- doDistribution

  pure parties

-- "CONTRACT_KEY_NOT_FOUND(11,7524fc1b): dependency error: couldn't find key: GlobalKey(8c0dc42d59ca5a69b73bc6173a8fee8b4c003fc2a868384b690ee50772a540c1:Daml.Finance.App.Data.AccountDirectory:AccountDirectory, ValueParty(TransferAgent-Money Market Tokenization::1220691b7f72e3a672ea5c867997e7e7b9085136661bd13de33ab3de2d728129a3f5))"