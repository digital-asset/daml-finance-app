-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Setup.Scenario.FXNetting where

import DA.Date (Month(..), date, toDateUTC, toGregorian)
import DA.Map (fromList)
import DA.Set (singleton)
import DA.Time (time)
import Daml.Finance.Account.Account qualified as Account (Factory(..))
import Daml.Finance.App.Lifecycle.Rule qualified as Claim (ClaimEffects (..))
import Daml.Finance.Holding.Fungible qualified as Fungible (Factory(..))
import Daml.Finance.Interface.Lifecycle.Rule.Lifecycle qualified as Lifecycle (Evolve(..))
import Daml.Finance.Interface.Types.Common.Types (Id(..))
import Daml.Finance.Interface.Util.Common (qty)
import Daml.Finance.Settlement.Hierarchy qualified as Settlement (Hierarchy(..))
import Daml.Finance.Setup.Util.Common
import Daml.Finance.Setup.Util.Role
import Daml.Finance.Setup.Util.Service
import Daml.Finance.Setup.Util.Workflow
import Daml.Script

run : Script [PartyInfo]
run = do
  let scenario = "FX Netting"
  parties <- allocateParties scenario ["Operator", "BankA", "BankB"] "Public"
  let
    all@[operator, bankA, bankB, public] = map (.id) parties
    pub = fromList [("Public", singleton public), ("Operator", singleton operator)]

  -- Factories
  let
    bankAInsts = ["USD", "GBP"]
    bankBInsts = ["EUR", "CHF"]
    bankARoute = Settlement.Hierarchy with rootCustodian = bankA; pathsToRootCustodian = [[bankB]]
    bankBRoute = Settlement.Hierarchy with rootCustodian = bankB; pathsToRootCustodian = [[bankA]]
    paths = fromList $ map (\i -> (i, bankARoute)) bankAInsts <> map (\i -> (i, bankBRoute)) bankBInsts
  accountFactoryCid <- toInterfaceContractId <$> submit operator do createCmd Account.Factory  with provider = operator; observers = pub
  holdingFactoryCid <- toInterfaceContractId <$> submit operator do createCmd Fungible.Factory with provider = operator; observers = pub

  -- Roles
  createOperatorRole operator
  createCustodianRole operator bankA
  createCustodianRole operator bankB
  createCustodianRole operator operator

  -- Services
  createCustodyService operator bankA bankB paths accountFactoryCid holdingFactoryCid
  bankACustodyServiceCid <- createCustodyService operator bankB bankA paths accountFactoryCid holdingFactoryCid
  createLifecycleService operator operator operator public
  createLifecycleService operator bankA bankB public
  bankALifecycleServiceCid <- createLifecycleService operator bankB bankA public

  -- Accounts
  bankACashAccount <- createAccount operator bankB bankA public "BankA@BankB|Cash" pub
  bankBCashAccount <- createAccount operator bankA bankB public "BankB@BankA|Cash" pub
  bankASecAccount  <- createAccount operator bankB bankA public "BankA@BankB|Sec" pub
  bankBSecAccount  <- createAccount operator bankA bankB public "BankB@BankA|Sec" pub

  -- Time
  t <- getTime
  let
    today = toDateUTC t
    todayTime = time today 0 0 0
    tt d = time d 0 0 0
    epoch = tt $ date 1970 Jan 1
    (ty, tm, td) = toGregorian today
    y year = date year tm td
  (clockCid, eventCid) <- createClockAndEvent all today (singleton public)

  -- Instruments
  usd <- originateToken operator operator pub epoch "USD" "US Dollar"
  eur <- originateToken operator operator pub epoch "EUR" "EURO"
  gbp <- originateToken operator operator pub epoch "GBP" "British Pound"
  chf <- originateToken operator operator pub epoch "CHF" "Swiss Frank"
  pmt <- originatePayment bankB bankA pub "PMT1"  "Payment -45m USD from BankA to BankB" today (-45_000_000.0) usd
  pvp1 <- originatePvP bankB bankA pub "PVP1" "PvP +100m USD vs -90m EUR" today 100_000_000.0 usd 90_000_000.0 eur
  pvp2 <- originatePvP bankB bankA pub "PVP2" "PvP -50m USD vs +40m GBP" today 40_000_000.0 gbp 50_000_000.0 usd
  pvp3 <- originatePvP bankB bankA pub "PVP3" "PvP -20m CHF vs +20m EUR" today 20_000_000.0 eur 20_000_000.0 chf
  pvp4 <- originatePvP bankB bankA pub "PVP4" "PvP +12m GBP vs -13m EUR" today 12_000_000.0 gbp 13_000_000.0 eur
  let ccys = [usd, eur, gbp, chf]

  -- Distribution
  pmtCid  <- deposit operator bankB bankA public (qty 1.0 pmt) bankASecAccount
  pvp1Cid <- deposit operator bankB bankA public (qty 1.0 pvp1) bankASecAccount
  pvp2Cid <- deposit operator bankB bankA public (qty 1.0 pvp2) bankASecAccount
  pvp3Cid <- deposit operator bankB bankA public (qty 1.0 pvp3) bankASecAccount
  pvp4Cid <- deposit operator bankB bankA public (qty 1.0 pvp4) bankASecAccount

  -- Data
  createAccountDirectory bankA (map (\ccy -> (ccy, bankACashAccount)) ccys) $ singleton public
  createAccountDirectory bankB (map (\ccy -> (ccy, bankBCashAccount)) ccys) $ singleton public

  -- Workflows
  let
    doLifecycle = do
      Some ls <- queryContractId operator bankALifecycleServiceCid
      (_, [effectCid1]) <- submitMulti [operator] [public] do exerciseCmd ls.genericRuleCid Lifecycle.Evolve with eventCid; instrument = pmt; observableCids = []
      (_, [effectCid2]) <- submitMulti [operator] [public] do exerciseCmd ls.genericRuleCid Lifecycle.Evolve with eventCid; instrument = pvp1; observableCids = []
      (_, [effectCid3]) <- submitMulti [operator] [public] do exerciseCmd ls.genericRuleCid Lifecycle.Evolve with eventCid; instrument = pvp2; observableCids = []
      (_, [effectCid4]) <- submitMulti [operator] [public] do exerciseCmd ls.genericRuleCid Lifecycle.Evolve with eventCid; instrument = pvp3; observableCids = []
      (_, [effectCid5]) <- submitMulti [operator] [public] do exerciseCmd ls.genericRuleCid Lifecycle.Evolve with eventCid; instrument = pvp4; observableCids = []

      Some cs <- queryContractId operator bankACustodyServiceCid
      let
        claimRuleCid = cs.claimRuleCid
        holdingCids = [pmtCid, pvp1Cid, pvp2Cid, pvp3Cid, pvp4Cid]
        effectCids = [effectCid1, effectCid2, effectCid3, effectCid4, effectCid5]
      submitMulti [operator] [public] do exerciseCmd cs.claimRuleCid Claim.ClaimEffects with claimer = operator; holdingCids; effectCids; batchId = Id "Batch1"
      pure ()
  --doLifecycle

  pure parties
