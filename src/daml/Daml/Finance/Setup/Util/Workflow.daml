-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Daml.Finance.Setup.Util.Workflow where

import DA.Date (toGregorian)
import DA.List (head)
import DA.Map (Map)
import DA.Set (Set, singleton)
import Daml.Finance.App.Custody.Service qualified as Custody (Deposit(..), RequestDeposit(..), Service)
import Daml.Finance.App.Distribution.Bidding.Model qualified as Bidding (Bid)
import Daml.Finance.App.Distribution.Bidding.Service qualified as Bidding (CreateBid(..), RequestCreateBid(..), S)
import Daml.Finance.App.Distribution.Auction.Model qualified as Auction (T)
import Daml.Finance.App.Distribution.Auction.Service qualified as Auction (CreateAuction(..), ProcessAuction(..), RequestCreateAuction(..), S)
import Daml.Finance.App.Issuance.Model qualified as Issuance (T)
import Daml.Finance.App.Issuance.Service qualified as Issuance (CreateIssuance(..), RequestCreateIssuance(..), Service)
import Daml.Finance.App.Listing.Model qualified as Listing (T)
import Daml.Finance.App.Listing.Service qualified as Listing (CreateListing(..), RequestCreateListing(..), Service)
import Daml.Finance.App.Trading.Model qualified as Trading (Order, Side(..))
import Daml.Finance.App.Trading.Service qualified as Trading (CreateOrder(..), RequestCreateOrder(..), Service)
import Daml.Finance.Instrument.Base.Instrument qualified as Base (Instrument(..))
import Daml.Finance.Instrument.Equity.Instrument qualified as Equity (Instrument(..))
import Daml.Finance.Instrument.Bond.FixedRate qualified as FixedRate (Instrument(..))
import Daml.Finance.Instrument.Bond.FloatingRate qualified as FloatingRate (Instrument(..))
import Daml.Finance.Instrument.Bond.InflationLinked qualified as InflationLinked (Instrument(..))
import Daml.Finance.Instrument.Bond.ZeroCoupon qualified as ZeroCoupon (Instrument(..))
import Daml.Finance.Instrument.Generic.Instrument qualified as Generic (Instrument(..))
import Daml.Finance.Interface.Holding.Account qualified as Account (K, View(..), R, toKey)
import Daml.Finance.Interface.Holding.Base qualified as Holding (I)
import Daml.Finance.Interface.Holding.Factory.Account qualified as Account (Create(..), F)
import Daml.Finance.Interface.Holding.Factory.Holding qualified as Holding (F)
import Daml.Finance.Interface.Holding.Fungible qualified as Fungible (I)
import Daml.Finance.Interface.Holding.Transferable qualified as Transferable (I, Transfer(..))
import Daml.Finance.Interface.Instrument.Base.Instrument qualified as Instrument (GetView(..), I, K, Q, Reference(..))
import Daml.Finance.Interface.Instrument.Generic.Types (C)
import Daml.Finance.Interface.Types.Common (Id(..), Parties)
import Daml.Finance.Interface.Types.Date.Calendar (BusinessDayAdjustment(..), BusinessDayConventionEnum)
import Daml.Finance.Interface.Types.Date.DayCount (DayCountConventionEnum)
import Daml.Finance.Interface.Types.Date.RollConvention (PeriodEnum, RollConventionEnum(..))
import Daml.Finance.Interface.Types.Date.Schedule (Frequency(..), PeriodicSchedule(..))
import Daml.Finance.Settlement.Factory qualified as Settlement (Factory)
import Daml.Finance.Setup.Util.Common (getHolding)
import Daml.Script (Script, createCmd, exerciseCmd, exerciseByKeyCmd, query, queryFilter, submitMulti)

-- | Create `Account`.
createAccount : [Party] -> ContractId Account.F -> ContractId Holding.F -> Map Text (Set Parties) -> Party -> Party -> Text -> Script Account.K
createAccount readAs factoryCid holdingFactoryCid observers custodian owner id = do
  let
    v = Account.View with custodian; owner; id = Id id; holdingFactoryCid; description = id
    k = Account.toKey v
  submitMulti [v.custodian, v.owner] readAs do
    exerciseCmd factoryCid Account.Create with account = k; holdingFactoryCid; observers; description = id
  pure k

-- | Create a `Reference` for an instrument.
-- Note: This should only be called together with an instrument creation
createReference : ContractId Instrument.I -> Party -> Party -> Map Text (Set Parties) -> Script Instrument.K
createReference cid depository issuer observers = do
  instrumentView <- submitMulti [depository, issuer] [] do exerciseCmd cid Instrument.GetView with viewer = issuer
  let ref = Instrument.Reference with instrumentView; cid; observers
  submitMulti [depository, issuer] [] do createCmd ref
  pure $ key ref

-- | Create a schedule for periodic payments.
createPaymentPeriodicSchedule : Date -> [Text] -> BusinessDayConventionEnum -> PeriodEnum -> Int -> Date -> Date -> PeriodicSchedule
createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate = do
  let
    (y, m, d) = toGregorian firstCouponDate
    periodicSchedule = PeriodicSchedule with
      businessDayAdjustment =
        BusinessDayAdjustment with
          calendarIds = holidayCalendarIds
          convention = businessDayConvention
      effectiveDateBusinessDayAdjustment = None
      terminationDateBusinessDayAdjustment = None
      frequency =
        Frequency with
          rollConvention = DOM d
          period = couponPeriod
          periodMultiplier = couponPeriodMultiplier
      effectiveDate = issueDate
      firstRegularPeriodStartDate = Some firstCouponDate
      lastRegularPeriodEndDate = Some maturityDate
      stubPeriodType = None
      terminationDate = maturityDate
  periodicSchedule

originate : Party -> Party -> Map Text (Set Parties) -> Time -> Text -> Text -> Script Instrument.K
originate depository issuer observers validAsOf id description = do
  cid <- coerceContractId <$> submitMulti [depository, issuer] [] do
    createCmd Base.Instrument with depository; issuer; id = Id id; version = "0"; observers; validAsOf; description
  createReference cid depository issuer observers

originateEquity : Party -> Party -> Map Text (Set Parties) -> Time -> Text -> Text -> Script Instrument.K
originateEquity depository issuer observers validAsOf id description = do
  cid <- coerceContractId <$> submitMulti [depository, issuer] [] do
    createCmd Equity.Instrument with depository; issuer; id = Id id; version = "0"; observers; validAsOf; description
  createReference cid depository issuer observers

originateGeneric : Party -> Party -> Map Text (Set Parties) -> Time -> Text -> C -> Script Instrument.K
originateGeneric depository issuer observers acquisitionTime id claims = do
  cid <- coerceContractId <$> submitMulti [depository, issuer] [] do
    createCmd Generic.Instrument with depository; issuer; id = Id id; version = "0"; acquisitionTime; claims; observers; lastEventTimestamp = acquisitionTime; description = id
  createReference cid depository issuer observers

originateFixedRateBond : Party -> Party -> Text -> Text -> Map Text (Set Parties) -> Time -> Date -> [Text] -> Party -> Date-> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Script Instrument.K
originateFixedRateBond depository issuer id description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  cid <- toInterfaceContractId @Instrument.I <$> submitMulti [depository, issuer] [] do
    createCmd FixedRate.Instrument with depository; issuer; id = Id id; version = "0"; description; observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; couponRate; currency
  createReference cid depository issuer observers

originateZeroCouponBond : Party -> Party -> Text -> Text -> Map Text (Set Parties) -> Time -> Date -> Date -> Instrument.K -> Script Instrument.K
originateZeroCouponBond depository issuer id description observers lastEventTimestamp issueDate maturityDate currency = do
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd ZeroCoupon.Instrument with depository; issuer; id = Id id; version = "0"; description; observers; lastEventTimestamp; issueDate; maturityDate; currency
  createReference cid depository issuer observers

originateFloatingRateBond : Party -> Party -> Text -> Text -> Map Text (Set Parties) -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Script Instrument.K
originateFloatingRateBond depository issuer id description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency referenceRateId = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd FloatingRate.Instrument with depository; issuer; id = Id id; version = "0"; description; observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; couponSpread=couponRate; referenceRateId; currency
  createReference cid depository issuer observers

originateInflationLinkedBond : Party -> Party -> Text -> Text -> Map Text (Set Parties) -> Time -> Date -> [Text] -> Party -> Date -> Date -> DayCountConventionEnum -> BusinessDayConventionEnum -> Decimal -> PeriodEnum -> Int -> Instrument.K -> Text -> Decimal -> Script Instrument.K
originateInflationLinkedBond depository issuer id description observers lastEventTimestamp issueDate holidayCalendarIds calendarDataProvider firstCouponDate maturityDate dayCountConvention businessDayConvention couponRate couponPeriod couponPeriodMultiplier currency inflationIndexId inflationIndexBaseValue = do
  let
    periodicSchedule = createPaymentPeriodicSchedule firstCouponDate holidayCalendarIds businessDayConvention couponPeriod couponPeriodMultiplier issueDate maturityDate
  cid <- toInterfaceContractId <$> submitMulti [depository, issuer] [] do
    createCmd InflationLinked.Instrument with depository; issuer; id = Id id; version = "0"; description; observers; lastEventTimestamp; periodicSchedule; holidayCalendarIds; calendarDataProvider; dayCountConvention; couponRate; inflationIndexId; currency; inflationIndexBaseValue
  createReference cid depository issuer observers

transfer : Party -> Account.K -> Party -> ContractId Transferable.I -> Script (ContractId Transferable.I)
transfer from toAccount public depositCid = do
  submitMulti [from, toAccount.owner] [public] do exerciseCmd depositCid Transferable.Transfer with newOwnerAccount = toAccount

deposit : Party -> Party -> Party -> Party -> Instrument.Q -> Account.K -> Script (ContractId Holding.I)
deposit operator provider customer public quantity account = do
  depositRequestCid <- submit customer do exerciseByKeyCmd @Custody.Service (operator, provider, customer) Custody.RequestDeposit with quantity; account
  submitMulti [provider] [public] do exerciseByKeyCmd @Custody.Service (operator, provider, customer) Custody.Deposit with depositRequestCid

issue : Party -> Party -> Party -> Party -> Instrument.Q -> Account.K -> Script (ContractId Issuance.T, ContractId Holding.I)
issue operator provider customer public quantity account = do
  let
    id = Id $ "ISSUANCE-" <> show quantity.unit.id
    description = "Issuance of " <> show quantity.amount <> " " <> show quantity.unit.id
  createIssuanceRequestCid <- submit customer do exerciseByKeyCmd @Issuance.Service (operator, provider, customer) Issuance.RequestCreateIssuance with id; description; quantity; account
  submitMulti [provider] [public] do exerciseByKeyCmd @Issuance.Service (operator, provider, customer) Issuance.CreateIssuance with ..

list : Party -> Party -> Party -> Text -> Instrument.K -> Instrument.K -> Parties -> Script (ContractId Listing.T)
list operator provider customer id tradedInstrument quotedInstrument observers = do
  createListingRequestCid <- submit customer do exerciseByKeyCmd @Listing.Service (operator, provider, customer) Listing.RequestCreateListing with id; tradedInstrument; quotedInstrument; observers
  submit provider do exerciseByKeyCmd @Listing.Service (operator, provider, customer) Listing.CreateListing with createListingRequestCid

createOrder : Party -> Party -> Party -> Party -> Text -> Trading.Side -> Instrument.Q -> Instrument.Q -> Parties -> Script (Optional (ContractId Trading.Order, Trading.Order))
createOrder operator provider customer public id side quantity price observers = do
  listingId <- (.id) . snd . head <$> queryFilter @Listing.T observers (\l -> l.tradedInstrument == quantity.unit && l.quotedInstrument == price.unit)
  let
    depository = if side == Trading.Buy then quantity.unit.depository else price.unit.depository
    requiredQuantity = if side == Trading.Buy then price with amount = price.amount * quantity.amount else quantity
  account <- key . snd . head <$> queryFilter @Account.R customer (\a -> a.accountView.custodian == depository)
  holdingCid <- coerceContractId <$> getHolding customer requiredQuantity
  orderCids <- map fst <$> queryFilter @Trading.Order observers (\o -> o.listingId == listingId)
  createOrderRequestCid <- submit customer do exerciseByKeyCmd @Trading.Service (operator, provider, customer) Trading.RequestCreateOrder with id; listingId; quantity; price; side; collateralCid = holdingCid; account; orderCids; observers
  submitMulti [provider] [public] do exerciseByKeyCmd @Trading.Service (operator, provider, customer) Trading.CreateOrder with createOrderRequestCid

createBidOrder : Party -> Party -> Party -> Party -> Text -> Instrument.Q -> Instrument.Q -> Parties -> Script (Optional (ContractId Trading.Order, Trading.Order))
createBidOrder operator provider customer public id = createOrder operator provider customer public id Trading.Buy

createAskOrder : Party -> Party -> Party -> Party -> Text -> Instrument.Q -> Instrument.Q -> Parties -> Script (Optional (ContractId Trading.Order, Trading.Order))
createAskOrder operator provider customer public id = createOrder operator provider customer public id Trading.Sell

createAuction : Party -> Party -> Party -> Party -> Text -> Instrument.Q -> Instrument.K -> Decimal -> ContractId Fungible.I -> Account.K -> Script (ContractId Auction.T)
createAuction operator provider customer public id quantity currency floor collateralCid receivableAccount = do
  createAuctionRequestCid <- submit customer do exerciseByKeyCmd @Auction.S (operator, provider, customer) Auction.RequestCreateAuction with id; quantity; currency; floor; collateralCid; receivableAccount; observers = singleton public
  submit provider do exerciseByKeyCmd @Auction.S (operator, provider, customer) Auction.CreateAuction with createAuctionRequestCid

createAuctionBid : Party -> Party -> Party -> Party -> ContractId Auction.T -> Decimal -> Decimal -> ContractId Fungible.I -> Account.K -> Script (ContractId Bidding.Bid)
createAuctionBid operator provider customer public auctionCid amount price collateralCid receivableAccount = do
  createBidRequestCid <- submitMulti [customer] [public] do exerciseByKeyCmd @Bidding.S (operator, provider, customer) Bidding.RequestCreateBid with auctionCid; amount; price; collateralCid; receivableAccount
  submit provider do exerciseByKeyCmd @Bidding.S (operator, provider, customer) Bidding.CreateBid with createBidRequestCid

processAuction : Party -> Party -> Party -> Party -> ContractId Auction.T -> [ContractId Bidding.Bid] -> Script (ContractId Auction.T)
processAuction operator provider customer public auctionCid bidCids = do
  [(factoryCid, _)] <- query @Settlement.Factory provider
  submitMulti [provider] [public] do
    exerciseByKeyCmd @Auction.S (operator, provider, customer) Auction.ProcessAuction
      with
        settlementFactoryCid = toInterfaceContractId factoryCid
        auctionCid
        bidCids
